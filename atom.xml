<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Luyoung</title>
  
  
  <link href="http://blog.luliang.online/atom.xml" rel="self"/>
  
  <link href="http://blog.luliang.online/"/>
  <updated>2025-02-18T13:55:24.278Z</updated>
  <id>http://blog.luliang.online/</id>
  
  <author>
    <name>Luyoung</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Rust 中的 traits</title>
    <link href="http://blog.luliang.online/2025/02/18/Rust%E4%B8%AD%E7%9A%84traits/"/>
    <id>http://blog.luliang.online/2025/02/18/Rust%E4%B8%AD%E7%9A%84traits/</id>
    <published>2025-02-18T07:18:27.000Z</published>
    <updated>2025-02-18T13:55:24.278Z</updated>
    
    <content type="html"><![CDATA[<h4 id="最近笔者在学-Rust，被-Rust-中精巧的设计深深吸引，尤其是-traits。它不仅能够应用到-Struct、Enum等，而且还能作为参数传入函数。"><a href="#最近笔者在学-Rust，被-Rust-中精巧的设计深深吸引，尤其是-traits。它不仅能够应用到-Struct、Enum等，而且还能作为参数传入函数。" class="headerlink" title="最近笔者在学 Rust，被 Rust 中精巧的设计深深吸引，尤其是 traits。它不仅能够应用到 Struct、Enum等，而且还能作为参数传入函数。"></a>最近笔者在学 Rust，被 Rust 中精巧的设计深深吸引，尤其是 traits。它不仅能够应用到 Struct、Enum等，而且还能作为参数传入函数。</h4><h2 id="应用于结构体"><a href="#应用于结构体" class="headerlink" title="应用于结构体"></a>应用于结构体</h2><p>先看这个例子：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs Rust"><span class="hljs-keyword">trait</span> <span class="hljs-title class_">Shape</span> &#123;<br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">area</span>(&amp;<span class="hljs-keyword">self</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">f64</span>; <span class="hljs-comment">// 计算面积</span><br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">perimeter</span>(&amp;<span class="hljs-keyword">self</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">f64</span>; <span class="hljs-comment">// 计算周长</span><br>&#125;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Circle</span> &#123;<br>    radius: <span class="hljs-type">f64</span>,<br>&#125;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Rectangle</span> &#123;<br>    width: <span class="hljs-type">f64</span>,<br>    height: <span class="hljs-type">f64</span>,<br>&#125;<br><br><span class="hljs-comment">// 为 Circle 结构体实现 Shape 特征</span><br><span class="hljs-keyword">impl</span> <span class="hljs-title class_">Shape</span> <span class="hljs-keyword">for</span> <span class="hljs-title class_">Circle</span> &#123;<br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">area</span>(&amp;<span class="hljs-keyword">self</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">f64</span> &#123;<br>        std::<span class="hljs-type">f64</span>::consts::PI * <span class="hljs-keyword">self</span>.radius * <span class="hljs-keyword">self</span>.radius<br>    &#125;<br><br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">perimeter</span>(&amp;<span class="hljs-keyword">self</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">f64</span> &#123;<br>        <span class="hljs-number">2.0</span> * std::<span class="hljs-type">f64</span>::consts::PI * <span class="hljs-keyword">self</span>.radius<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 为 Rectangle 结构体实现 Shape 特征</span><br><span class="hljs-keyword">impl</span> <span class="hljs-title class_">Shape</span> <span class="hljs-keyword">for</span> <span class="hljs-title class_">Rectangle</span> &#123;<br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">area</span>(&amp;<span class="hljs-keyword">self</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">f64</span> &#123;<br>        <span class="hljs-keyword">self</span>.width * <span class="hljs-keyword">self</span>.height<br>    &#125;<br><br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">perimeter</span>(&amp;<span class="hljs-keyword">self</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">f64</span> &#123;<br>        <span class="hljs-number">2.0</span> * (<span class="hljs-keyword">self</span>.width + <span class="hljs-keyword">self</span>.height)<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">circle</span> = Circle &#123; radius: <span class="hljs-number">5.0</span> &#125;;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">rectangle</span> = Rectangle &#123; width: <span class="hljs-number">4.0</span>, height: <span class="hljs-number">6.0</span> &#125;;<br><br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;Circle Area: &#123;&#125;, Perimeter: &#123;&#125;&quot;</span>, circle.<span class="hljs-title function_ invoke__">area</span>(), circle.<span class="hljs-title function_ invoke__">perimeter</span>());<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;Rectangle Area: &#123;&#125;, Perimeter: &#123;&#125;&quot;</span>, rectangle.<span class="hljs-title function_ invoke__">area</span>(), rectangle.<span class="hljs-title function_ invoke__">perimeter</span>());<br>&#125;<br></code></pre></td></tr></table></figure><p>这个例子是一个很简单的例子，就是将 trait 应用在具体的 Struct 上。类似的还有Enum。如果这就是 traits 的全部，那么 traits 将不值一提。</p><h2 id="作为函数参数"><a href="#作为函数参数" class="headerlink" title="作为函数参数"></a>作为函数参数</h2><p>看这个例子：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs Rust"><span class="hljs-keyword">trait</span> <span class="hljs-title class_">Shape</span> &#123;<br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">area</span>(&amp;<span class="hljs-keyword">self</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">f64</span>;<br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">perimeter</span>(&amp;<span class="hljs-keyword">self</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">f64</span>;<br>&#125;<br><br><span class="hljs-comment">// ... (Circle 和 Rectangle 结构体以及 Shape 特征的实现，与前面的例子相同) ...</span><br><br><span class="hljs-comment">// 泛型函数，接受任何实现了 Shape 特征的类型 T</span><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">print_shape_info</span>&lt;T: Shape&gt;(shape: &amp;T) &#123;<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;Area: &#123;&#125;, Perimeter: &#123;&#125;&quot;</span>, shape.<span class="hljs-title function_ invoke__">area</span>(), shape.<span class="hljs-title function_ invoke__">perimeter</span>());<br>&#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">circle</span> = Circle &#123; radius: <span class="hljs-number">5.0</span> &#125;;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">rectangle</span> = Rectangle &#123; width: <span class="hljs-number">4.0</span>, height: <span class="hljs-number">6.0</span> &#125;;<br><br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;Circle:&quot;</span>);<br>    <span class="hljs-title function_ invoke__">print_shape_info</span>(&amp;circle); <span class="hljs-comment">// 传入 Circle 实例</span><br><br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;Rectangle:&quot;</span>);<br>    <span class="hljs-title function_ invoke__">print_shape_info</span>(&amp;rectangle); <span class="hljs-comment">// 传入 Rectangle 实例</span><br>&#125;<br></code></pre></td></tr></table></figure><p>这里的函数 <code>print_shape_info</code> 接受一个泛型，但是函数签名对这个泛型做出了限制<code>&lt;T: Shape&gt;</code>：要求这个泛型实现了Shape traits。</p><p>这意味着，随便定义一个类型，只要给这个类型加一个特征，比如 Display，那么这个类型就能使用所有可以接受 Display 的方法。</p><p>比如：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs Rust"><span class="hljs-keyword">use</span> std::fmt; <span class="hljs-comment">// 需要引入 fmt 模块才能使用 Display trait</span><br><br><span class="hljs-meta">#[derive(Debug)]</span> <span class="hljs-comment">// 为了方便打印 Point 结构体</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Point</span> &#123;<br>    x: <span class="hljs-type">i32</span>,<br>    y: <span class="hljs-type">i32</span>,<br>&#125;<br><br><span class="hljs-comment">// 为 Point 结构体实现 Display 特征</span><br><span class="hljs-keyword">impl</span> <span class="hljs-title class_">fmt</span>::Display <span class="hljs-keyword">for</span> <span class="hljs-title class_">Point</span> &#123;<br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">fmt</span>(&amp;<span class="hljs-keyword">self</span>, f: &amp;<span class="hljs-keyword">mut</span> fmt::Formatter&lt;<span class="hljs-symbol">&#x27;_</span>&gt;) <span class="hljs-punctuation">-&gt;</span> fmt::<span class="hljs-type">Result</span> &#123;<br>        <span class="hljs-built_in">write!</span>(f, <span class="hljs-string">&quot;(&#123;&#125;, &#123;&#125;)&quot;</span>, <span class="hljs-keyword">self</span>.x, <span class="hljs-keyword">self</span>.y) <span class="hljs-comment">// 定义 Point 的 Display 格式</span><br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">p</span> = Point &#123; x: <span class="hljs-number">10</span>, y: <span class="hljs-number">20</span> &#125;;<br><br>    <span class="hljs-comment">// 因为 Point 实现了 Display 特征，所以可以使用 println! 宏的 &quot;&#123;&#125;&quot; 格式化</span><br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;Point p: &#123;&#125;&quot;</span>, p); <span class="hljs-comment">// 输出: Point p: (10, 20)</span><br><br>    <span class="hljs-comment">// 也可以将 Point 传递给任何接受 Display trait 的函数或宏</span><br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">message</span> = <span class="hljs-built_in">format!</span>(<span class="hljs-string">&quot;The point is: &#123;&#125;&quot;</span>, p);<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>, message); <span class="hljs-comment">// 输出: The point is: The point is: (10, 20)</span><br>&#125;<br></code></pre></td></tr></table></figure><p>甚至，在这个例子中，实现了 <code>Display</code> 的类型 自动 实现了 <code>ToString</code> 特征，而 <code>to_string()</code> 方法是由 <code>ToString</code> 特征提供的。</p><p><code>ToString</code> 的自动实现 (Blanket Implementation):  Rust 标准库为所有实现了 <code>Display</code> 特征的类型，自动提供了一个 <code>ToString</code> 特征的实现 (blanket implementation)。  这个 blanket implementation 大致是这样的 (简化版)：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs Rust"><span class="hljs-keyword">impl</span>&lt;T: fmt::Display&gt; <span class="hljs-built_in">ToString</span> <span class="hljs-keyword">for</span> <span class="hljs-title class_">T</span> &#123;<br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">to_string</span>(&amp;<span class="hljs-keyword">self</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">String</span> &#123;<br>        <span class="hljs-built_in">format!</span>(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>, <span class="hljs-keyword">self</span>) <span class="hljs-comment">// 内部使用 Display 特征进行格式化</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;最近笔者在学-Rust，被-Rust-中精巧的设计深深吸引，尤其是-traits。它不仅能够应用到-Struct、Enum等，而且还能作为参数传入函数。&quot;&gt;&lt;a href=&quot;#最近笔者在学-Rust，被-Rust-中精巧的设计深深吸引，尤其是-traits。它不仅</summary>
      
    
    
    
    <category term="编程语言" scheme="http://blog.luliang.online/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
    <category term="Rust" scheme="http://blog.luliang.online/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Rust/"/>
    
    
    <category term="Rust" scheme="http://blog.luliang.online/tags/Rust/"/>
    
    <category term="Java" scheme="http://blog.luliang.online/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>ssh 免密登录失效问题</title>
    <link href="http://blog.luliang.online/2025/02/15/%E8%AE%B0%E5%BD%95%E4%B8%80%E6%AC%A1%E5%A5%87%E6%80%AA%E7%9A%84ssh%E5%85%8D%E5%AF%86%E7%99%BB%E5%BD%95%E5%A4%B1%E6%95%88%E9%97%AE%E9%A2%98/"/>
    <id>http://blog.luliang.online/2025/02/15/%E8%AE%B0%E5%BD%95%E4%B8%80%E6%AC%A1%E5%A5%87%E6%80%AA%E7%9A%84ssh%E5%85%8D%E5%AF%86%E7%99%BB%E5%BD%95%E5%A4%B1%E6%95%88%E9%97%AE%E9%A2%98/</id>
    <published>2025-02-15T07:18:27.000Z</published>
    <updated>2025-02-18T13:55:24.291Z</updated>
    
    <content type="html"><![CDATA[<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>突然间我发现我需要密码才能登录到服务器，但是我仔细对比检查了私钥和秘钥，发现一切正常。这是什么原因呢？</p><h2 id="问题原因"><a href="#问题原因" class="headerlink" title="问题原因"></a>问题原因</h2><p>原来，前几天我用 snap 安装了 hugo，hugo 需要文件夹权限，为了让 snap 应用访问用户家目录下的文件，我按照网上教程将家目录权限修改为 777。</p><p>ssh 为了保证通信安全，防止 key 被篡改或窃取，对目录和文件的权限要求相当严格：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">chmod</span> 0755 ~<br><span class="hljs-built_in">chmod</span> 700 ~/.ssh<br><span class="hljs-built_in">chmod</span> 600 ~/.ssh/authorized_keys<br><br>sudo service sshd restart<br></code></pre></td></tr></table></figure><p>SSH 服务程序 sshd 启动时，会 严格检查 home，.ssh 目录和 authorized_keys 文件的权限。 如果权限不符合要求，sshd 会 拒绝使用公钥认证，并可能退回到密码认证，或者直接拒绝连接，以避免潜在的安全风险。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;问题&quot;&gt;&lt;a href=&quot;#问题&quot; class=&quot;headerlink&quot; title=&quot;问题&quot;&gt;&lt;/a&gt;问题&lt;/h2&gt;&lt;p&gt;突然间我发现我需要密码才能登录到服务器，但是我仔细对比检查了私钥和秘钥，发现一切正常。这是什么原因呢？&lt;/p&gt;
&lt;h2 id=&quot;问题原因&quot;&gt;</summary>
      
    
    
    
    <category term="Ubuntu" scheme="http://blog.luliang.online/categories/Ubuntu/"/>
    
    
    <category term="ssh" scheme="http://blog.luliang.online/tags/ssh/"/>
    
    <category term="snap" scheme="http://blog.luliang.online/tags/snap/"/>
    
  </entry>
  
  <entry>
    <title>使用 GitHub Actions 自动发布 Hexo 博客</title>
    <link href="http://blog.luliang.online/2025/02/11/%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8github_action%E8%87%AA%E5%8A%A8%E9%83%A8%E7%BD%B2%E5%8D%9A%E5%AE%A2/"/>
    <id>http://blog.luliang.online/2025/02/11/%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8github_action%E8%87%AA%E5%8A%A8%E9%83%A8%E7%BD%B2%E5%8D%9A%E5%AE%A2/</id>
    <published>2025-02-11T02:20:40.000Z</published>
    <updated>2025-02-18T13:55:24.288Z</updated>
    
    <content type="html"><![CDATA[<span id="more"></span><h2 id="Github-Actions-的原理"><a href="#Github-Actions-的原理" class="headerlink" title="Github Actions 的原理"></a>Github Actions 的原理</h2><p>按照我的理解就是，首先GitHub 提供了一个虚拟主机，这个主机是干净的。当你需要使用它的时候，你首先得制作一个简单的部署或者测试环境，这是通过 pull docker 镜像或者安装一些软件实现的，甚至你还得配置一些秘钥啥的来访问特定操作（后面有例子）。总之，第一步得配置好环境。</p><p>第二步，就是你要在这个机器上要做的事情了，事实上，第一步的时候你已经做了一些事情了，比如安装一些必要的软件来创建所需要的环境。不同的是，这时候就得来做你想要做的事情了。比如编译一些目标、部署一下博客（这篇文章的主题）。</p><p>所以 Actions 的原理很好理解，接下来就看要怎么操作才能创建一个 Hexo 生成、部署（github push）的环境了。</p><h2 id="设置权限"><a href="#设置权限" class="headerlink" title="设置权限"></a>设置权限</h2><p>为什么是设置权限呢？这是因为我们部署的原理的要求。首先我们需要在 A 仓库中写 mark down 博客，然后在根目录中执行一些 hexo 命令来将生成的网页等文件push 到 B 仓库。A 仓库一般是隐私的，存储着我们的 markdown 格式的博客，而 B 仓库一般是我们的目标仓库，一般是公开的，比如 <code>luyoung0001.github.io</code>。</p><p>问题是，当我们需要将 A 仓库生成的网页等文件 push 到 B 仓库时，是需要权限的，因此我们的环境设置中必须要有权限设置，从而可以使得在 A 目录中通过 <code>hexo d</code> 的时候可以成功将生成的代码 push 到 B 仓库中。</p><p>权限怎么设置呢？其实 GitHub 已经贴心的将这个需求解决了。我们只需要生成一对密钥，将私钥放在 A，将公钥放在 B。</p><p>首先在你本机生成密钥对：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">ssh-keygen -f github-deploy-key<br></code></pre></td></tr></table></figure><p>一路回车，当前目录下就会生成 <code>github-deploy-key</code> 和 <code>github-deploy-key.pub</code>。</p><p>接着，设置 A 仓库和 B 仓库的公钥和私钥：</p><p>对于 A 仓库：进入仓库页面 → Settings → Secrets and variables → actions → New repository secret，Name 填 HEXO_DEPLOY_PRI ，Secret 填 github-deploy-key 的内容。</p><p>对于 B 仓库：进入仓库页面 → Settings → Deploy keys → Add deploy key，Title 填 HEXO_DEPLOY_PUB ，Key 填 github-deploy-key.pub 的内容。</p><p>这里的需要注意的是，你需要将私钥整个复制，包括 <code>-----BEGIN OPENSSH PRIVATE KEY-----</code>:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cat</span> github-deploy-key<br>-----BEGIN OPENSSH PRIVATE KEY-----<br>...<br></code></pre></td></tr></table></figure><h2 id="Actions-脚本"><a href="#Actions-脚本" class="headerlink" title="Actions 脚本"></a>Actions 脚本</h2><p>我这里直接给出脚本：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs YML"><span class="hljs-attr">name:</span> <span class="hljs-string">Deploy</span> <span class="hljs-string">hexo</span> <span class="hljs-string">blog</span><br><br><span class="hljs-attr">on:</span><br>  <span class="hljs-attr">push:</span><br>    <span class="hljs-attr">branches:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-string">master</span><br><br><span class="hljs-attr">jobs:</span><br>  <span class="hljs-attr">build:</span><br>    <span class="hljs-attr">runs-on:</span> <span class="hljs-string">ubuntu-latest</span><br>    <span class="hljs-attr">strategy:</span><br>      <span class="hljs-attr">matrix:</span><br>        <span class="hljs-attr">node-version:</span> [<span class="hljs-number">20.</span><span class="hljs-string">x</span>]<br><br>    <span class="hljs-attr">steps:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">uses:</span> <span class="hljs-string">actions/checkout@v4</span><br><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">Use</span> <span class="hljs-string">Node.js</span> <span class="hljs-string">$&#123;&#123;</span> <span class="hljs-string">matrix.node-version</span> <span class="hljs-string">&#125;&#125;</span><br>        <span class="hljs-attr">uses:</span> <span class="hljs-string">actions/setup-node@v4</span><br>        <span class="hljs-attr">with:</span><br>          <span class="hljs-attr">node-version:</span> <span class="hljs-string">$&#123;&#123;</span> <span class="hljs-string">matrix.node-version</span> <span class="hljs-string">&#125;&#125;</span><br><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">Configuration</span> <span class="hljs-string">environment</span><br>        <span class="hljs-attr">env:</span><br>          <span class="hljs-attr">HEXO_DEPLOY_PRI:</span> <span class="hljs-string">$&#123;&#123;secrets.HEXO_DEPLOY_PRI&#125;&#125;</span><br>        <span class="hljs-attr">run:</span> <span class="hljs-string">|</span><br><span class="hljs-string">          sudo timedatectl set-timezone &quot;Asia/Shanghai&quot;</span><br><span class="hljs-string">          mkdir -p ~/.ssh/</span><br><span class="hljs-string">          echo &quot;$HEXO_DEPLOY_PRI&quot; | tr -d &#x27;\r&#x27; &gt; ~/.ssh/id_rsa</span><br><span class="hljs-string">          chmod 600 ~/.ssh/id_rsa</span><br><span class="hljs-string">          ssh-keyscan github.com &gt;&gt; ~/.ssh/known_hosts</span><br><span class="hljs-string">          git config --global user.name &quot;你的 github 用户名&quot;</span><br><span class="hljs-string">          git config --global user.email &quot;你的 github 邮箱&quot;</span><br><span class="hljs-string"></span>      <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">Install</span> <span class="hljs-string">dependencies</span><br>        <span class="hljs-attr">run:</span> <span class="hljs-string">|</span><br><span class="hljs-string">          npm i -g hexo-cli</span><br><span class="hljs-string">          npm ci</span><br><span class="hljs-string"></span>      <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">Deploy</span> <span class="hljs-string">hexo</span><br>        <span class="hljs-attr">run:</span> <span class="hljs-string">|</span><br><span class="hljs-string">          rm -rf .deploy_git</span><br><span class="hljs-string">          hexo clean</span><br><span class="hljs-string">          hexo d -g</span><br></code></pre></td></tr></table></figure><p>需要注意的是：</p><ul><li>设置时区很重要。平常我们在自己电脑上部署都是 GMT+8 时区，但是执行 GitHub action 的 runner 在美国，可不是这个时区，所以我们要改下时区，否则如果你的博文地址是 年&#x2F;月&#x2F;日 这种形式的话，可能会出现有些博文访问不了的问题。</li><li>SSH 密钥。这里选择的事 ssh，而之前你部署的时候使用的是 http，那么你需要修改 dev 目录下 _config.yml 中的 deploy 字段中的 repo，改为 ssh 地址，即：</li></ul><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs YML"><span class="hljs-attr">deploy:</span><br>  <span class="hljs-attr">type:</span> <span class="hljs-string">git</span><br>  <span class="hljs-attr">repo:</span> <span class="hljs-string">https://github.com/secsilm/secsilm.github.io.git</span><br>  <span class="hljs-attr">branch:</span> <span class="hljs-string">master</span><br><br><span class="hljs-comment"># 应改为：</span><br><span class="hljs-attr">deploy:</span><br>  <span class="hljs-attr">type:</span> <span class="hljs-string">git</span><br>  <span class="hljs-attr">repo:</span> <span class="hljs-string">git@github.com:secsilm/secsilm.github.io.git</span><br>  <span class="hljs-attr">branch:</span> <span class="hljs-string">master</span><br></code></pre></td></tr></table></figure><p>你也可以配合大模型来仔细查看那个脚本的具体含义，总之就是环境+操作。</p><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p>你可以进行一次更改提交，看看 action 是否正常执行。你可以在 GitHub Actions 页面查看每次运行的日志。</p><p>这里一般会遇到几个小问题：</p><h3 id="权限"><a href="#权限" class="headerlink" title="权限"></a>权限</h3><p>可能报这个错误：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash">...<br>Load key <span class="hljs-string">&quot;/home/runner/.ssh/id_rsa&quot;</span>: error <span class="hljs-keyword">in</span> libcrypto<br>git@github.com: Permission denied (publickey).<br>fatal: Could not <span class="hljs-built_in">read</span> from remote repository.<br><br>Please make sure you have the correct access rights<br>and the repository exists.<br></code></pre></td></tr></table></figure><p>前面已经提到，你必须把私钥所有的内容复制到 repository secret。</p><h3 id="部署失败"><a href="#部署失败" class="headerlink" title="部署失败"></a>部署失败</h3><p>可能报这个错误：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash">...<br>INFO  540 files generated <span class="hljs-keyword">in</span> 1.98 s<br>INFO  Deploying: git<br>INFO  Clearing .deploy_git folder...<br>INFO  Copying files from public folder...<br>INFO  Copying files from extend <span class="hljs-built_in">dirs</span>...<br>fatal: <span class="hljs-keyword">in</span> unpopulated submodule <span class="hljs-string">&#x27;.deploy_git&#x27;</span><br>...<br></code></pre></td></tr></table></figure><p>解决办法是：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">rm</span> -rf .deploy_git<br></code></pre></td></tr></table></figure><p>这个我已经加到脚本了，不会再遇到了。</p><p>这篇博客就是通过 Actons 部署，再也不用本地环境了，由于网络的关系，使得某些过程可能会卡很久，但是 Actions 不会存在网络问题，只要你能 push 成功。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;span id=&quot;more&quot;&gt;&lt;/span&gt;

&lt;h2 id=&quot;Github-Actions-的原理&quot;&gt;&lt;a href=&quot;#Github-Actions-的原理&quot; class=&quot;headerlink&quot; title=&quot;Github Actions 的原理&quot;&gt;&lt;/a&gt;Github </summary>
      
    
    
    
    <category term="Blog" scheme="http://blog.luliang.online/categories/Blog/"/>
    
    
    <category term="Hexo" scheme="http://blog.luliang.online/tags/Hexo/"/>
    
    <category term="GitHub_Actions" scheme="http://blog.luliang.online/tags/GitHub-Actions/"/>
    
  </entry>
  
  <entry>
    <title>对 SPI、FLASH 的思考</title>
    <link href="http://blog.luliang.online/2025/02/09/spi_flash%E6%84%9F%E6%83%B3/"/>
    <id>http://blog.luliang.online/2025/02/09/spi_flash%E6%84%9F%E6%83%B3/</id>
    <published>2025-02-09T08:20:40.000Z</published>
    <updated>2025-02-18T13:55:24.283Z</updated>
    
    <content type="html"><![CDATA[<span id="more"></span><h2 id="从-flash-中读出数据（1）"><a href="#从-flash-中读出数据（1）" class="headerlink" title="从 flash 中读出数据（1）"></a>从 flash 中读出数据（1）</h2><p>之前在 <code>ysyxSoC/perip/spi/rtl/spi_top_apb.v</code> 中定义宏 <code>FAST_FLASH</code>，因此当程序访问 <code>0x30000000+X</code> 的时候，就会访问这个模块：</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs Verilog"><span class="hljs-meta">`<span class="hljs-keyword">ifdef</span> FAST_FLASH</span><br><br><span class="hljs-keyword">wire</span> [<span class="hljs-number">31</span>:<span class="hljs-number">0</span>] data;<br><span class="hljs-keyword">parameter</span> invalid_cmd = <span class="hljs-number">8&#x27;h0</span>;<br>flash_cmd flash_cmd_i(<br>  <span class="hljs-variable">.clock</span>(clock),<br>  <span class="hljs-variable">.valid</span>(in_psel &amp;&amp; !in_penable),<br>  <span class="hljs-variable">.cmd</span>(in_pwrite ? invalid_cmd : <span class="hljs-number">8&#x27;h03</span>),<br>  <span class="hljs-variable">.addr</span>(&#123;<span class="hljs-number">8&#x27;b0</span>, in_paddr[<span class="hljs-number">23</span>:<span class="hljs-number">2</span>], <span class="hljs-number">2&#x27;b0</span>&#125;),<br>  <span class="hljs-variable">.data</span>(data)<br>);<br><span class="hljs-keyword">assign</span> spi_sck    = <span class="hljs-number">1&#x27;b0</span>;<br><span class="hljs-keyword">assign</span> spi_ss     = <span class="hljs-number">8&#x27;b0</span>;<br><span class="hljs-keyword">assign</span> spi_mosi   = <span class="hljs-number">1&#x27;b1</span>;<br><span class="hljs-keyword">assign</span> spi_irq_out= <span class="hljs-number">1&#x27;b0</span>;<br><span class="hljs-keyword">assign</span> in_pslverr = <span class="hljs-number">1&#x27;b0</span>;<br><span class="hljs-keyword">assign</span> in_pready  = in_penable &amp;&amp; in_psel &amp;&amp; !in_pwrite;<br><span class="hljs-keyword">assign</span> in_prdata  = data[<span class="hljs-number">31</span>:<span class="hljs-number">0</span>];<br></code></pre></td></tr></table></figure><p>接着就是：</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs Verilog"><span class="hljs-meta">`<span class="hljs-keyword">ifdef</span> FAST_FLASH</span><br><br><span class="hljs-keyword">wire</span> [<span class="hljs-number">31</span>:<span class="hljs-number">0</span>] data;<br><span class="hljs-keyword">parameter</span> invalid_cmd = <span class="hljs-number">8&#x27;h0</span>;<br>flash_cmd flash_cmd_i(<br>  <span class="hljs-variable">.clock</span>(clock),<br>  <span class="hljs-variable">.valid</span>(in_psel &amp;&amp; !in_penable),<br>  <span class="hljs-variable">.cmd</span>(in_pwrite ? invalid_cmd : <span class="hljs-number">8&#x27;h03</span>),<br>  <span class="hljs-variable">.addr</span>(&#123;<span class="hljs-number">8&#x27;b0</span>, in_paddr[<span class="hljs-number">23</span>:<span class="hljs-number">2</span>], <span class="hljs-number">2&#x27;b0</span>&#125;),<br>  <span class="hljs-variable">.data</span>(data)<br>);<br><span class="hljs-keyword">assign</span> spi_sck    = <span class="hljs-number">1&#x27;b0</span>;<br><span class="hljs-keyword">assign</span> spi_ss     = <span class="hljs-number">8&#x27;b0</span>;<br><span class="hljs-keyword">assign</span> spi_mosi   = <span class="hljs-number">1&#x27;b1</span>;<br><span class="hljs-keyword">assign</span> spi_irq_out= <span class="hljs-number">1&#x27;b0</span>;<br><span class="hljs-keyword">assign</span> in_pslverr = <span class="hljs-number">1&#x27;b0</span>;<br><span class="hljs-keyword">assign</span> in_pready  = in_penable &amp;&amp; in_psel &amp;&amp; !in_pwrite;<br><span class="hljs-keyword">assign</span> in_prdata  = data[<span class="hljs-number">31</span>:<span class="hljs-number">0</span>];<br></code></pre></td></tr></table></figure><p>这样，其实就直接从用户自定义的 DPI-C 返回了，因此这很FAST，因为中间没有经过协议。</p><h2 id="从-flash-中读出数据（2）"><a href="#从-flash-中读出数据（2）" class="headerlink" title="从 flash 中读出数据（2）"></a>从 flash 中读出数据（2）</h2><p>现实中，flash 并不是上面这样工作的，上面只是一个 flash 工作的非常粗略的行为级别模拟。</p><p>事实上，flash 的访问是需要控制器的，这里的例子是 spi-top。</p><p>当程序访问 flash 的时候（<code>0x30000000+X</code>），依然会经过 xbar 路由到 <code>ysyxSoC/perip/spi/rtl/spi_top_apb.v</code> 模块中的 APB 端口。</p><p>当注释掉 FAST_FLASH 时，模块 spi_top 将会起作用：</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs Verilog">spi_top u0_spi_top (<br>  <span class="hljs-variable">.wb_clk_i</span>(clock),<br>  <span class="hljs-variable">.wb_rst_i</span>(reset),<br>  <span class="hljs-variable">.wb_adr_i</span>(in_paddr[<span class="hljs-number">4</span>:<span class="hljs-number">0</span>]),<br>  <span class="hljs-variable">.wb_dat_i</span>(in_pwdata),<br>  <span class="hljs-variable">.wb_dat_o</span>(in_prdata),<br>  <span class="hljs-variable">.wb_sel_i</span>(in_pstrb),<br>  <span class="hljs-variable">.wb_we_i</span> (in_pwrite),<br>  <span class="hljs-variable">.wb_stb_i</span>(in_psel),<br>  <span class="hljs-variable">.wb_cyc_i</span>(in_penable),<br>  <span class="hljs-variable">.wb_ack_o</span>(in_pready),<br>  <span class="hljs-variable">.wb_err_o</span>(in_pslverr),<br>  <span class="hljs-variable">.wb_int_o</span>(spi_irq_out),<br><br>  <span class="hljs-variable">.ss_pad_o</span>(spi_ss),<br>  <span class="hljs-variable">.sclk_pad_o</span>(spi_sck),<br>  <span class="hljs-variable">.mosi_pad_o</span>(spi_mosi),<br>  <span class="hljs-variable">.miso_pad_i</span>(spi_miso)<br>);<br></code></pre></td></tr></table></figure><p>也就是说，这时候访问的其实是 spi_top，spi_top 会和 spi_shift 结合，然后spi_shift 和 flash 这类 slave 设备连接。</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs Scala"><span class="hljs-keyword">val</span> flash = <span class="hljs-type">Module</span>(<span class="hljs-keyword">new</span> flash)<br>flash.io &lt;&gt; masic.spi<br>flash.io.ss := masic.spi.ss(<span class="hljs-number">0</span>)<br></code></pre></td></tr></table></figure><p>之后，就会发生数据交换，拿到数据后，再返回给程序。</p><p>因此这个过程非常慢，在后面的 XIP 下运行 cpu-tests，就会发现运行得非常非常慢。</p><h2 id="运行-char-test（1）"><a href="#运行-char-test（1）" class="headerlink" title="运行 char_test（1）"></a>运行 char_test（1）</h2><p>刚开始，把 char_test 的 bin 文件装在 sram 中，这最简单，直接就能运行。整个架构是，将 bin 放在 sram 中后，直接让 NPC 的 PC 指向 sram 的起始地址，就可以跑了。这个过程不涉及任何 mrom、flash。</p><h2 id="运行-char-test（2）"><a href="#运行-char-test（2）" class="headerlink" title="运行 char_test（2）"></a>运行 char_test（2）</h2><p>接着，就要把 char_test 的 bin 文件放在 mrom 中了，这里面就要做很多事情了，比如要修改链接脚本，要把 <code>.data section</code> 通过类似的 bootloader 的方式搬到 sram。然后 NPC 的 PC 指向 mrom 的起始地址开始执行。这一切目前还好。</p><h2 id="运行-char-test（3）"><a href="#运行-char-test（3）" class="headerlink" title="运行 char_test（3）"></a>运行 char_test（3）</h2><p>现在情况复杂起来了，我们有了 flash，还是带有 spi 的真正意义上的 flash。</p><p>要访问 flash，首先就得有一个程序 A，它能够通过特定的步骤来读取 flash，这使得我们可以通过 A 来将装载到flash 中的 char_test 的 bin 文件搬到 sram 中。而且 A 还可以直接跳转到 sram 中执行 char_test。</p><p>首先，我们把 A 程序装载 mrom 中，NPC 的 PC 指向 mrom 的起始地址执行 A，然后 A 就会开始搬运工作，搬运工作完成后就跳转到 sram 执行 char_test。</p><p>可以看到，A 的行为有点像什么？操作系统？A 可以通过一系列步骤访问 flash，准确地来说是 spi-master。然后 A 还可以将访问到的数据加载到 sram，接着再跳转到 sram 执行目标程序。</p><p>那么这样就很麻烦。</p><h2 id="运行-char-test（4）"><a href="#运行-char-test（4）" class="headerlink" title="运行 char_test（4）"></a>运行 char_test（4）</h2><p>我们的目标是什么？是在大量便宜的存储单元中运行程序，因此我们需要便宜的可编程的 flash，而不是昂贵每次都要重新光刻的 mrom，以及少量的 sram（为了提高性能，事实上，如果不嫌弃慢的话，sram 都不需要）。</p><p>因此，我们的想法是，为什么不直接在 flash 中执行程序呢？</p><p>实际上，在装载程序本身的地方直接执行程序叫做<code>就地执行</code>(XIP, eXecute In Place)方式。</p><p>但是我们必须保留程序 A 的一部分功能，它必须能通过 spi-master 来访问flash，而且我们必须把 A 放在 mrom 中，NPC 可以访问 mrom 中的 A 程序来获取 flash 中的第一条指令，接着访问 mrom 中的 A 程序来获取 flash 中的第二条指令……</p><p>可以看到，这很麻烦，每次在 flash 中执行目标程序 char_test，都要访问辅助程序 A，效率相当底下。</p><h2 id="运行-char-test（5）"><a href="#运行-char-test（5）" class="headerlink" title="运行 char_test（5）"></a>运行 char_test（5）</h2><p>因此，我们想到的是，直接将 程序A 用物理器件代替，直接让它成为 spi_top_apb 的一部分，这样，CPU 的 IFU 访问 flash 时，直接就能取到指令，就像访问sram 和 mrom 一样。</p><p>这就是最终的目标。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;span id=&quot;more&quot;&gt;&lt;/span&gt;

&lt;h2 id=&quot;从-flash-中读出数据（1）&quot;&gt;&lt;a href=&quot;#从-flash-中读出数据（1）&quot; class=&quot;headerlink&quot; title=&quot;从 flash 中读出数据（1）&quot;&gt;&lt;/a&gt;从 flash 中读出数据</summary>
      
    
    
    
    <category term="ysyx" scheme="http://blog.luliang.online/categories/ysyx/"/>
    
    
    <category term="flash" scheme="http://blog.luliang.online/tags/flash/"/>
    
    <category term="SPI" scheme="http://blog.luliang.online/tags/SPI/"/>
    
  </entry>
  
  <entry>
    <title>C语言内联汇编</title>
    <link href="http://blog.luliang.online/2025/02/06/%E5%86%85%E8%81%94%E6%B1%87%E7%BC%96/"/>
    <id>http://blog.luliang.online/2025/02/06/%E5%86%85%E8%81%94%E6%B1%87%E7%BC%96/</id>
    <published>2025-02-06T06:01:27.000Z</published>
    <updated>2025-02-18T13:55:24.288Z</updated>
    
    <content type="html"><![CDATA[<span id="more"></span><h2 id="一个示例"><a href="#一个示例" class="headerlink" title="一个示例"></a>一个示例</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">asm</span> <span class="hljs-title function_">volatile</span><span class="hljs-params">(</span><br><span class="hljs-params">       <span class="hljs-string">&quot;jalr x0, 0(%0)&quot;</span></span><br><span class="hljs-params">       :</span><br><span class="hljs-params">       : <span class="hljs-string">&quot;r&quot;</span>(jump_address)</span><br><span class="hljs-params">       :</span><br><span class="hljs-params">   )</span>;<br></code></pre></td></tr></table></figure><p><strong>代码片段的格式和含义分解：</strong></p><p>这段代码使用了 GCC 扩展内联汇编的通用格式，其基本结构如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">asm</span> [<span class="hljs-keyword">volatile</span>] (<br>  汇编指令模板 :  <span class="hljs-comment">// 字符串，包含汇编指令和占位符</span><br>  输出操作数列表 : <span class="hljs-comment">// 可选，指定汇编指令的输出操作数</span><br>  输入操作数列表 : <span class="hljs-comment">// 可选，指定汇编指令的输入操作数</span><br>  破坏列表        <span class="hljs-comment">// 可选，指定汇编指令可能修改的寄存器或内存</span><br>);<br></code></pre></td></tr></table></figure><ol><li><p><strong><code>asm volatile(</code></strong></p><ul><li><strong><code>asm</code></strong>:  关键字，表示开始内联汇编代码块。</li><li><strong><code>volatile</code></strong>:  可选关键字。使用 <code>volatile</code> 的目的是告诉编译器，这段内联汇编代码具有<strong>副作用</strong>（例如，修改了内存或影响了程序状态），<strong>不要对这段代码进行任何优化</strong>，每次调用都必须严格按照代码编写的顺序执行。在跳转指令这种场景下，通常需要使用 <code>volatile</code>，以确保跳转行为不被编译器优化掉。</li></ul></li><li><p><strong><code>&quot;jalr x0, 0(%0)&quot;</code></strong></p><ul><li>这是 <strong>汇编指令模板</strong>，是一个<strong>字符串</strong>，包含了实际的 RISC-V 汇编指令。</li><li><strong><code>jalr x0, 0(%0)</code></strong>:  这是 RISC-V 的 <strong>跳转指令</strong>。<ul><li><strong><code>jalr</code></strong>:  指令名，表示 “Jump and Link Register”。 它会执行跳转，并将返回地址（跳转指令的下一条指令的地址）保存在指定的寄存器中，但在这里，由于目标寄存器是 <code>x0</code> (zero 寄存器)，所以实际上忽略了返回地址的保存，它只执行跳转功能。</li><li><strong><code>x0</code></strong>:  目标寄存器，用于存放返回地址。 在这里被指定为 <code>x0</code>，表示<strong>不保存返回地址，只进行跳转</strong>。</li><li><strong><code>0(%0)</code></strong>:  跳转目标地址的计算方式。<ul><li><strong><code>%0</code></strong>:  这是一个**占位符 (Placeholder)**，用于在汇编指令模板中引用 C 语言的变量。  <code>%0</code> 表示 <strong>第一个操作数</strong> (这里的第一个操作数指的是后面 <code>输入操作数列表</code> 中的第一个操作数)。</li><li><strong><code>(%0)</code></strong>:  表示 <strong>间接寻址</strong>。  它会将 <code>%0</code>  所代表的寄存器中的值，作为<strong>内存地址</strong>，并从该内存地址读取数据。</li><li><strong><code>0(%0)</code> 完整含义</strong>:  表示跳转目标地址是：<strong>寄存器 <code>%0</code> 中存储的地址值 + 偏移量 0</strong>。  实际上就是直接使用寄存器 <code>%0</code> 中的值作为跳转目标地址。</li></ul></li></ul></li></ul></li><li><p><strong><code>:                 // 输出操作数:  无</code></strong></p><ul><li><strong>输出操作数列表</strong>:  位于第一个冒号 <code>:</code> 之后，用于指定汇编指令的<strong>输出操作数</strong>。</li><li><strong><code>:</code> 之后为空</strong>:  表示这段汇编代码 <strong>没有输出操作数</strong>，即汇编指令执行后，不会将结果值写回到 C 语言的变量中。</li></ul></li><li><p><strong><code>: &quot;r&quot;(jump_address)  // 输入操作数:  jump_address (C变量) 映射到寄存器</code></strong></p><ul><li><strong>输入操作数列表</strong>:  位于第二个冒号 <code>:</code> 之后，用于指定汇编指令的<strong>输入操作数</strong>。</li><li><strong><code>&quot;r&quot;(jump_address)</code></strong>:  指定了一个输入操作数。<ul><li><strong><code>&quot;r&quot;</code></strong>:  <strong>约束 (Constraint) 字符串</strong>。  <code>&quot;r&quot;</code> 约束告诉编译器，将 <code>jump_address</code> 这个 C 变量 <strong>分配到一个通用寄存器</strong> (register)。  编译器会选择一个合适的通用寄存器，并将 <code>jump_address</code> 的值加载到这个寄存器中，然后在汇编指令模板中使用 <code>%0</code> 占位符来引用这个寄存器。</li><li><strong><code>(jump_address)</code></strong>:  <strong>C 语言表达式</strong>。  <code>jump_address</code> 是一个 C 变量，它提供了汇编指令所需的输入值，即跳转的目标地址。</li></ul></li></ul></li><li><p><strong><code>: &quot;memory&quot;  // 破坏性操作: 无</code></strong></p><ul><li><strong>破坏列表 (Clobber List)</strong>: 位于第三个冒号 <code>:</code> 之后，用于告诉编译器，这段内联汇编代码可能会<strong>修改某些寄存器或内存位置</strong>，从而阻止编译器进行某些可能导致错误的优化。</li><li><strong><code>&quot;memory&quot;</code></strong>:  <strong>破坏描述符 (Clobber Descriptor)<strong>。 <code>&quot;memory&quot;</code> 告知编译器，这段内联汇编代码可能会</strong>修改内存中的数据</strong>。  即使代码中没有显式地写内存操作指令，但如果汇编代码的执行可能导致内存状态改变（例如，跳转到未知的代码区域，该区域的代码可能会修改内存），也需要使用 <code>&quot;memory&quot;</code>  来保守地告诉编译器，防止编译器做出错误的假设。  在本例中，虽然 <code>jalr</code> 指令本身不直接修改内存，但由于它是一个跳转指令，可能会跳转到任意地址的代码执行，为了安全起见，使用 <code>&quot;memory&quot;</code> 是一个好的实践。</li><li><strong><code>: &quot;memory&quot;</code> 完整含义</strong>:  表示这段内联汇编代码可能会修改内存。</li></ul></li></ol><p><strong>代码功能：</strong></p><p>这段内嵌汇编代码的功能是： **执行一个间接跳转 (register jump)**。  跳转的目标地址  <strong>由 C 变量 <code>jump_address</code> 的值来指定</strong>。  代码会将 <code>jump_address</code> 的值加载到一个寄存器中，然后使用 <code>jalr x0, 0(register)</code> 指令，以寄存器中的值作为目标地址进行跳转，但不保存返回地址。  由于使用了 <code>volatile</code> 和 <code>&quot;memory&quot;</code> clobber，编译器会保证这段代码被严格执行，并且不会因为优化而产生意外的行为。  这种代码通常用于需要直接控制程序流程，例如跳转到特定的地址执行某些初始化代码、处理异常、或者实现某些特殊的控制流逻辑等场景。</p><hr><h2 id="基本语法格式"><a href="#基本语法格式" class="headerlink" title="基本语法格式"></a>基本语法格式</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">asm</span> [<span class="hljs-keyword">volatile</span>] (<br>  <span class="hljs-string">&quot;assembly code template&quot;</span><br>  : [output operands]<br>  : [input operands]<br>  : [clobber <span class="hljs-built_in">list</span>]<br>);<br></code></pre></td></tr></table></figure><ul><li><strong><code>asm</code></strong>:  关键字，开始内联汇编块。</li><li><strong><code>[volatile]</code></strong>:  可选，<code>volatile</code> 关键字告知编译器不要优化这段汇编代码。</li><li><strong><code>&quot;assembly code template&quot;</code></strong>:  汇编指令字符串，可以包含多条指令，指令之间用分号 <code>;</code> 或换行符 <code>\n</code> 分隔。  可以使用占位符 <code>%0</code>, <code>%1</code>, <code>%2</code>…  引用操作数。</li><li><strong><code>: [output operands]</code></strong>:  可选，输出操作数列表。  每个输出操作数形如 <code>&quot;[约束](C 变量)&quot;</code>，多个操作数用逗号 <code>,</code> 分隔。</li><li><strong><code>: [input operands]</code></strong>:  可选，输入操作数列表。  每个输入操作数形如 <code>&quot;[约束](C 表达式)&quot;</code>，多个操作数用逗号 <code>,</code> 分隔。</li><li><strong><code>: [clobber list]</code></strong>:  可选，破坏列表。  用双引号 <code>&quot; &quot;</code> 括起来的寄存器名或特殊符号（如 <code>&quot;memory&quot;</code>），多个破坏描述符用逗号 <code>,</code> 分隔。</li></ul><h2 id="操作数和约束-Operands-and-Constraints"><a href="#操作数和约束-Operands-and-Constraints" class="headerlink" title="操作数和约束 (Operands and Constraints)"></a>操作数和约束 (Operands and Constraints)</h2><p>操作数用于在 C 代码和汇编代码之间传递数据。 约束字符串用于指定操作数的类型和位置 (寄存器、内存等)。</p><p><strong>常用约束 (RISC-V GCC 常用约束，更完整的约束列表请查阅 GCC RISC-V 扩展文档):</strong></p><ul><li><strong><code>r</code></strong>:  通用寄存器 (General-purpose register)。 编译器会为操作数分配一个合适的通用寄存器 (例如 <code>x1</code> - <code>x31</code>)。</li><li><strong><code>i</code></strong>:  立即数 (immediate value)。  操作数是一个编译时可知的立即数 (整数常量)。</li><li><strong><code>f</code></strong>:  浮点寄存器 (Floating-point register) (用于浮点操作)。  RISC-V 32 位架构中，通常使用扩展指令集 ‘F’ 或 ‘D’  支持浮点运算。</li><li><strong><code>m</code></strong>:  内存操作数 (memory operand)。  操作数是一个内存地址。</li><li><strong><code>I</code></strong>:  0-31 范围内的立即数 (适用于移位指令的移位量)。</li></ul><p><strong>操作数占位符:</strong></p><ul><li>在汇编指令模板中，使用 <code>%0</code>, <code>%1</code>, <code>%2</code>…  来引用操作数。</li><li><code>%0</code> 对应第一个操作数，<code>%1</code> 对应第二个操作数，以此类推。</li><li>输出操作数从 <code>%0</code> 开始编号，输入操作数从输出操作数之后继续编号。 例如，如果有一个输出操作数，那么第一个输入操作数就是 <code>%1</code>。</li><li>在 RISC-V 汇编中，寄存器通常用 <code>x0</code>, <code>x1</code>, <code>x2</code>… 表示，而在内联汇编的操作数中，我们使用占位符 <code>%0</code>, <code>%1</code>…  ，编译器会负责将这些占位符替换为实际分配的寄存器或立即数。</li></ul><h2 id="破坏列表-Clobber-List"><a href="#破坏列表-Clobber-List" class="headerlink" title="破坏列表 (Clobber List)"></a>破坏列表 (Clobber List)</h2><ul><li>破坏列表用于告知编译器，内联汇编代码可能会修改某些资源，从而影响编译器的优化决策。</li><li><strong>常用破坏描述符:</strong><ul><li><strong>寄存器名 (例如 <code>&quot;x1&quot;</code>, <code>&quot;x5&quot;</code>, <code>&quot;x10&quot;</code>)</strong>:  表示汇编代码可能会修改指定的寄存器。  如果汇编代码显式地修改了某个寄存器，或者依赖于某个寄存器的值，就应该将其添加到破坏列表中。</li><li><strong><code>&quot;memory&quot;</code></strong>:  表示汇编代码可能会修改内存。  当汇编代码访问了内存（例如，通过 <code>lw</code> 或 <code>sw</code> 指令，或者像 <code>jalr</code> 这样的跳转指令可能执行未知的内存操作），就应该使用 <code>&quot;memory&quot;</code>。</li><li><strong><code>&quot;cc&quot;</code></strong>:  表示汇编代码可能会修改条件码寄存器 (Condition Code register,  RISC-V 中条件码隐含在比较指令和分支指令中，通常不需要显式 clobber “cc”)。</li></ul></li></ul><h2 id="简单示例教程-RISC-V-32"><a href="#简单示例教程-RISC-V-32" class="headerlink" title="简单示例教程 (RISC-V 32)"></a>简单示例教程 (RISC-V 32)</h2><p><strong>示例 1:  将立即数加载到寄存器</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>  <span class="hljs-type">int</span> value;<br>  <span class="hljs-keyword">asm</span> (<br>    <span class="hljs-string">&quot;li %0, 100&quot;</span>   <span class="hljs-comment">// RISC-V: li (load immediate) 指令，将 100 加载到寄存器</span><br>    : <span class="hljs-string">&quot;=r&quot;</span>(value)  <span class="hljs-comment">// 输出操作数: value (C变量) 映射到寄存器，使用 &quot;=r&quot; 表示输出，且分配寄存器</span><br>    :              <span class="hljs-comment">// 输入操作数: 无</span><br>    :              <span class="hljs-comment">// 破坏列表: 无</span><br>  );<br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Value: %d\n&quot;</span>, value); <span class="hljs-comment">// 输出 value 的值，应该是 100</span><br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><strong><code>&quot;li %0, 100&quot;</code></strong>:  汇编指令模板，<code>li</code> (load immediate) 指令将立即数 100 加载到寄存器 <code>%0</code>。</li><li><strong><code>&quot;=r&quot;(value)</code></strong>:  输出操作数。<ul><li><strong><code>=r</code></strong>:  约束字符串。 <code>=</code> 表示输出操作数 (write-only)，<code>r</code> 表示分配通用寄存器。</li><li><strong>(value)</strong>:  C 变量 <code>value</code>，汇编指令的执行结果将存储到这个变量中。</li></ul></li><li><strong>输出</strong>: 程序会输出 “Value: 100”。</li></ul><p><strong>示例 2:  寄存器加法</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>  <span class="hljs-type">int</span> a = <span class="hljs-number">5</span>, b = <span class="hljs-number">10</span>, sum;<br>  <span class="hljs-keyword">asm</span> (<br>    <span class="hljs-string">&quot;add %0, %1, %2&quot;</span>  <span class="hljs-comment">// RISC-V: add 指令，将 %1 和 %2 相加，结果存入 %0</span><br>    : <span class="hljs-string">&quot;=r&quot;</span>(sum)       <span class="hljs-comment">// 输出操作数: sum (C变量)，分配寄存器，结果写入 sum</span><br>    : <span class="hljs-string">&quot;r&quot;</span>(a), <span class="hljs-string">&quot;r&quot;</span>(b)  <span class="hljs-comment">// 输入操作数: a 和 b (C变量)，分配寄存器，作为加法指令的输入</span><br>    :                 <span class="hljs-comment">// 破坏列表: 无</span><br>  );<br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Sum: %d\n&quot;</span>, sum); <span class="hljs-comment">// 输出 sum 的值，应该是 15</span><br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><strong><code>&quot;add %0, %1, %2&quot;</code></strong>: RISC-V <code>add</code> 指令，将寄存器 <code>%1</code> 和 <code>%2</code> 的值相加，结果存入寄存器 <code>%0</code>。</li><li><strong><code>&quot;=r&quot;(sum)</code></strong>:  输出操作数，结果写入 C 变量 <code>sum</code>。</li><li><strong><code>&quot;r&quot;(a), &quot;r&quot;(b)</code></strong>:  输入操作数，C 变量 <code>a</code> 和 <code>b</code> 的值作为加法指令的输入。</li><li><strong>输出</strong>: 程序会输出 “Sum: 15”。</li></ul><p><strong>示例 3:  内存加载 (Load Word) 和破坏列表</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>  <span class="hljs-type">int</span> data_in_memory = <span class="hljs-number">0x12345678</span>;<br>  <span class="hljs-type">int</span> loaded_value;<br>  <span class="hljs-type">int</span> *addr_ptr = &amp;data_in_memory;<br><br>  <span class="hljs-keyword">asm</span> <span class="hljs-title function_">volatile</span> <span class="hljs-params">(</span><br><span class="hljs-params">    <span class="hljs-string">&quot;lw %0, (%1)&quot;</span>     <span class="hljs-comment">// RISC-V: lw (load word) 指令，从地址 (%1) 加载一个字到 %0</span></span><br><span class="hljs-params">    : <span class="hljs-string">&quot;=r&quot;</span>(loaded_value) <span class="hljs-comment">// 输出操作数: loaded_value (C变量)</span></span><br><span class="hljs-params">    : <span class="hljs-string">&quot;r&quot;</span>(addr_ptr)     <span class="hljs-comment">// 输入操作数: addr_ptr (C变量，指向内存地址)</span></span><br><span class="hljs-params">    : <span class="hljs-string">&quot;memory&quot;</span>         <span class="hljs-comment">// 破坏列表: &quot;memory&quot;，表示汇编代码可能会访问内存</span></span><br><span class="hljs-params">  )</span>;<br><br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Loaded value: 0x%x\n&quot;</span>, loaded_value); <span class="hljs-comment">// 输出从内存加载的值，应该是 0x12345678</span><br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><strong><code>&quot;lw %0, (%1)&quot;</code></strong>:  RISC-V <code>lw</code> (load word) 指令，从内存地址 <code>(%1)</code> 加载一个 32 位字到寄存器 <code>%0</code>。</li><li><strong><code>&quot;=r&quot;(loaded_value)</code></strong>: 输出操作数，加载的值存入 <code>loaded_value</code>。</li><li><strong><code>&quot;r&quot;(addr_ptr)</code></strong>:  输入操作数，C 指针变量 <code>addr_ptr</code>  (包含内存地址) 作为加载指令的地址来源。</li><li><strong><code>&quot;memory&quot;</code></strong>:  破坏列表，因为 <code>lw</code> 指令会从内存中读取数据，因此使用 <code>&quot;memory&quot;</code> 是必要的，尽管本例中并没有 <em>修改</em> 内存，但 <code>lw</code> 指令的内存访问也可能影响编译器的优化假设。</li><li><strong>输出</strong>: 程序会输出 “Loaded value: 0x12345678”。</li></ul><p>C 语言内联汇编提供了一种在 C 代码中直接编写汇编指令的方式，可以实现一些用纯 C 代码难以或无法完成的底层操作和优化。 掌握内联汇编的关键在于理解其语法格式、操作数约束、破坏列表，并结合具体的处理器架构（如 RISC-V）的汇编指令集进行实践。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;span id=&quot;more&quot;&gt;&lt;/span&gt;
&lt;h2 id=&quot;一个示例&quot;&gt;&lt;a href=&quot;#一个示例&quot; class=&quot;headerlink&quot; title=&quot;一个示例&quot;&gt;&lt;/a&gt;一个示例&lt;/h2&gt;&lt;figure class=&quot;highlight c&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;t</summary>
      
    
    
    
    <category term="C语言" scheme="http://blog.luliang.online/categories/C%E8%AF%AD%E8%A8%80/"/>
    
    
    <category term="汇编" scheme="http://blog.luliang.online/tags/%E6%B1%87%E7%BC%96/"/>
    
  </entry>
  
  <entry>
    <title>docker 加速最佳解决方案</title>
    <link href="http://blog.luliang.online/2025/01/16/docker%E5%8A%A0%E9%80%9F%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"/>
    <id>http://blog.luliang.online/2025/01/16/docker%E5%8A%A0%E9%80%9F%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/</id>
    <published>2025-01-16T06:01:27.000Z</published>
    <updated>2025-02-18T13:55:24.280Z</updated>
    
    <content type="html"><![CDATA[<span id="more"></span><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>docker 在 pull 镜像的时候，速度要么很慢，要么直接卡住报错，这是因为网络不通的原因。主要有两个思路，方案一就是换源，将 docker 的仓库换到镜像源上，因为镜像源在国内，因此这种方式便宜。但缺点是镜像可能会在某个时间节点停止服务，不够稳定。方案二就是不用管源的事情，直接在本地架设代理，缺点是技术门槛高，需要架设代理，还需要支付额外的流量费。优点是源不会挂掉，很稳定。</p><h2 id="方案一"><a href="#方案一" class="headerlink" title="方案一"></a>方案一</h2><p>创建或修改 &#x2F;etc&#x2F;docker&#x2F;daemon.json 文件，修改：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cd</span> /etc/docker<br>vim daemon.json<br></code></pre></td></tr></table></figure><p>加入如下配置：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs bash">&#123;<br>    <span class="hljs-string">&quot;registry-mirrors&quot;</span> : [<br>    <span class="hljs-string">&quot;https://registry.docker-cn.com&quot;</span>,<br>    <span class="hljs-string">&quot;http://hub-mirror.c.163.com&quot;</span>,<br>    <span class="hljs-string">&quot;https://docker.mirrors.ustc.edu.cn&quot;</span>,<br>    <span class="hljs-string">&quot;https://cr.console.aliyun.com&quot;</span>,<br>    <span class="hljs-string">&quot;https://mirror.ccs.tencentyun.com&quot;</span><br>  ]<br>&#125;<br></code></pre></td></tr></table></figure><p>重启docker服务使配置生效：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">systemctl daemon-reload<br>systemctl restart docker.service<br></code></pre></td></tr></table></figure><p>这个方案可能还有一些问题，使得不能正常工作。</p><h2 id="方案二"><a href="#方案二" class="headerlink" title="方案二"></a>方案二</h2><p>编辑 &#x2F;etc&#x2F;systemd&#x2F;system&#x2F;docker.service.d&#x2F;http-proxy.conf 文件（如果文件不存在，则创建路径以及文件）：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo nano /etc/systemd/system/docker.service.d/http-proxy.conf<br><br></code></pre></td></tr></table></figure><p>添加或修改以下内容，将 <proxy_url> 替换为你的代理地址：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">[Service]<br>Environment=<span class="hljs-string">&quot;HTTP_PROXY=http://&lt;proxy_url&gt;:&lt;port&gt;&quot;</span><br>Environment=<span class="hljs-string">&quot;HTTPS_PROXY=https://&lt;proxy_url&gt;:&lt;port&gt;&quot;</span><br><br></code></pre></td></tr></table></figure><p>修改完成后，运行以下命令以重启 Docker 服务并应用配置：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo systemctl daemon-reload<br>sudo systemctl restart docker<br><br></code></pre></td></tr></table></figure><p>Docker 客户端在拉取镜像时，会按照以下顺序尝试：</p><ul><li>检查本地是否存在镜像： 如果本地存在所需镜像，则直接使用本地镜像。</li><li>检查配置的镜像加速器： 如果配置了镜像加速器，则依次尝试从加速器拉取镜像。</li><li>连接 Docker Hub： 如果所有加速器都无法拉取镜像，则尝试直接连接 Docker Hub。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;span id=&quot;more&quot;&gt;&lt;/span&gt;

&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;docker 在 pull 镜像的时候，速度要么很慢，要么直接卡住报错，这是因为网络不通的</summary>
      
    
    
    
    <category term="工具" scheme="http://blog.luliang.online/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
    <category term="tools" scheme="http://blog.luliang.online/tags/tools/"/>
    
  </entry>
  
  <entry>
    <title>2024 个人总结</title>
    <link href="http://blog.luliang.online/2025/01/09/2024%E5%B9%B4%E5%BA%A6%E6%80%BB%E7%BB%93/"/>
    <id>http://blog.luliang.online/2025/01/09/2024%E5%B9%B4%E5%BA%A6%E6%80%BB%E7%BB%93/</id>
    <published>2025-01-09T06:01:27.000Z</published>
    <updated>2025-02-18T13:55:24.269Z</updated>
    
    <content type="html"><![CDATA[<span id="more"></span><h2 id="2023-年的目标"><a href="#2023-年的目标" class="headerlink" title="2023 年的目标"></a>2023 年的目标</h2><p>“因此在 2024 年，我将会学习更多的关于算法（CS61B）、计算机网络（CS114）、 数据库、编译原理、Java（面向实习学习）、分布式等知识，争取能在暑假拿到offer。”</p><p>上述言论是我在 2023年12月31 在博客中提到的。当时我的想法是学习 Java 后端，学习通用的 Java 学习路线，然后在暑假拿到 实习offer。</p><p>但最终，2024 年一整年，我的学习内容可以说是和上面的没有任何关系。在这篇博客中，我会谈到我为什么会发生这样的转变。事实上，如果我在 2024 年真的去做 Java 后端了，我是很有信心能在暑假拿到 实习offer 的，因为我在 2023 年已经有了一个很不错的 Java 的基础，学习更高级的 JavaWeb 是没有任何障碍的。</p><p>我没有选择 Java 后端的原因比较多，大概是我对计算机系统结构的兴趣、我对计算机底层原理的好奇和我对职业生涯周期的担忧的综合的结果。下面我将会谈到我的看法（均是我的个人看法，请理性看待）。</p><h2 id="AI-的崛起"><a href="#AI-的崛起" class="headerlink" title="AI 的崛起"></a>AI 的崛起</h2><p>如果在 2023 年说到，AI 会取代程序员，我会嗤之以鼻，因为我是真的在 2023 年初期用过 AI 来辅助写代码并且那时候我感到它一点都不强，无非就是只是生成一些简单的代码框架，类似于模版的东西。至于那时候网上铺天盖地的程序员要被 AI 取代的信息我一点都不相信。甚至为了方便，我在网上使用了一个开源项目，把 gpt 做到了命令行工具里，那时候是 gpt3.5，它会犯很多我能轻易察觉到的错误。比如有时候它会误解 C++11中的某些知识，我还得给它纠正，然后我才能继续下一步。</p><p>在 2024 年 6 月份的时候，事情变了，我接触到了 gpt4.0。通过使用 gpt4.0，我第一次感受到了 AI 的迅猛和进化速度，它几乎能回答我关于编程知识任何疑问，包括修改代码、给出 bug 解决方案等等。gpt4.0 远比 3.5 强。3.5 如果是一个小学生的话，4.0 就是一个很厉害的大学生。</p><p>如果按照这个趋势发展，程序员的工作效率可能会增加 10 倍甚至几十倍都是有可能的。而需求增长是缓慢的，这意味着将会有大量的程序员失业，留下的往往是名校+高学历等 buff 加成的。而普通大学生呢？这就是一个关键问题了。</p><p>因此从那个时候，我开始认真思考这些类似于 “AI 取代程序员” 的信息了。</p><p>到 6 月份，上学期快结束了，我主要就是学习了 C++11等，还做了两个小项目，刷了一些 leetcode。</p><h2 id="再谈-AI"><a href="#再谈-AI" class="headerlink" title="再谈 AI"></a>再谈 AI</h2><p>这学期我选了一门本选研的课程《高级编译原理》，这门课是本科生和研究生一起上的。这门课提供了两个实验。一个是词法分析，一个是语法分析。</p><p>词法分析是我用 rust 写的，语法分析比较复杂且我对 rust 掌握有限，所以我用 C 语言完成了它。</p><p>我做语法分析的时候，使用了 vscode 中提供的 Copilot。使用的体验是，Copilot 太强了。我写代码喜欢先写注释，结果我刚写完注释，它就知道我要干什么，接着就给我生成了几十行代码，我直接 Tab，然后编译运行，结果是，他真能跑。</p><p>尽管生成后的代码依然存在部分问题，但是也仅仅在我微调之后，它的功能就很完善了。这样我的效率增加了至少 3 倍，一下午就写好了，包括文法、消除递归和嵌套、LL1 判断、构建分析表等等。</p><p>我的问题是，Copilot 在 5 年后将会发展到多强？由于前端代码在代码数据中占大多数，那么训练出来的模型可能将会最擅长前端代码的生成，前端框架、前端项目甚至都可以直接给出。</p><p>另外还有Java、C++后端等，增删改查、常见需求在 AI 的加持下，不难想象，对于涉及的程序员的需求将会大大减少。</p><p>这对于很多程序员的职业生涯将会是很大的打击，因为历史经验告诉我们，生产力的爆炸式增长，并不会带来工作时长的减少。同时需求增长的速度具有滞后性，因为很多需求是需要人为创造的，因此它具有滞后性。程序员的职业生涯可能将会非常短暂。</p><h2 id="写一个-CPU"><a href="#写一个-CPU" class="headerlink" title="写一个 CPU"></a>写一个 CPU</h2><p>6月份的时候，有一个朋友给我推荐一生一芯项目，我看了官网的介绍和一些讲义大纲之后，顿时来了兴趣，经过 10 左右的思考和了解，我决定开始学习一生一芯。因为写一个 CPU，然后在自己写的 CPU 上启动 Linux 或者自己的操作系统。我想，这件事情太酷了，任何一个喜欢计算机的都很难抵挡这种诱惑。</p><p>经过了一个暑假和三次答辩，终于在开学最后一个周末，通过了入门考核，那真的让人振奋。</p><p>开学后，自然是全职做 ysyx。中间的痛苦和快乐真的让人回味无穷。印象最深刻的是接入 SoC 后我给自己埋的一个 Bug坑了我好几天，每天在那里 debug 10小时都无济于事。还好最后解决了。</p><p>其它的有意思的事情在这里就不多说了，文字难以表达的东西太多了。</p><h2 id="未来要做什么"><a href="#未来要做什么" class="headerlink" title="未来要做什么"></a>未来要做什么</h2><p>未来要做什么，这个问题我思考了很久很久。首先，我的工作必须不是那么很容易被取代的，这让我向往底层；其次，我必须得提高计算系统结构这方面的能力，这对我来说相当重要，否则我就不会来再一次读这个本科了；最后，我喜欢分享，我希望等我掌握足够多的知识后，能活跃于各个社区。</p><p>当下就是去好好实习，学习尽可能贴近生产的技术和技能。接着就是龙芯杯、编译器、操作系统这些东西，也就是掌握计算机系统结构所涉及的一切。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;span id=&quot;more&quot;&gt;&lt;/span&gt;

&lt;h2 id=&quot;2023-年的目标&quot;&gt;&lt;a href=&quot;#2023-年的目标&quot; class=&quot;headerlink&quot; title=&quot;2023 年的目标&quot;&gt;&lt;/a&gt;2023 年的目标&lt;/h2&gt;&lt;p&gt;“因此在 2024 年，我将会学习</summary>
      
    
    
    
    <category term="Personal_Summary" scheme="http://blog.luliang.online/categories/Personal-Summary/"/>
    
    
    <category term="个人总结" scheme="http://blog.luliang.online/tags/%E4%B8%AA%E4%BA%BA%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>再探究异常处理</title>
    <link href="http://blog.luliang.online/2024/11/19/%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/"/>
    <id>http://blog.luliang.online/2024/11/19/%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/</id>
    <published>2024-11-19T08:20:40.000Z</published>
    <updated>2025-02-18T13:55:24.289Z</updated>
    
    <content type="html"><![CDATA[<span id="more"></span><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>阅读本案例需要有做 nemu 的经历，最低要求是是做到 PA3.1。</p><h2 id="一个最简单的异常处理程序"><a href="#一个最简单的异常处理程序" class="headerlink" title="一个最简单的异常处理程序"></a>一个最简单的异常处理程序</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;klib.h&gt;</span></span><br><span class="hljs-type">void</span> <span class="hljs-title function_">handler</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">uintptr_t</span> mepc;<br>    <span class="hljs-keyword">asm</span> <span class="hljs-title function_">volatile</span><span class="hljs-params">(<span class="hljs-string">&quot;csrr %0, mepc&quot;</span> : <span class="hljs-string">&quot;=r&quot;</span>(mepc))</span>;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;exception at mepc = %p\n&quot;</span>, mepc);<br>    <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>)<br>        ;<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">asm</span> <span class="hljs-title function_">volatile</span><span class="hljs-params">(<span class="hljs-string">&quot;csrw mtvec, %0&quot;</span> : : <span class="hljs-string">&quot;r&quot;</span>(handler))</span>;<br>    <span class="hljs-keyword">asm</span> <span class="hljs-title function_">volatile</span><span class="hljs-params">(<span class="hljs-string">&quot;.word 0&quot;</span>)</span>;  <span class="hljs-comment">// illegal instruction</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;I am alive!\n&quot;</span>);<br>    <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>)<br>        ;<br>&#125;<br></code></pre></td></tr></table></figure><p>这是 Makefile：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs Makefile"><br>NAME = simple-rv-handler<br>SRCS = simple-rv-handler.c<br><span class="hljs-keyword">include</span> <span class="hljs-variable">$(AM_HOME)</span>/Makefile<br><br></code></pre></td></tr></table></figure><h3 id="在-riscv32—nemu-运行"><a href="#在-riscv32—nemu-运行" class="headerlink" title="在 riscv32—nemu 运行"></a>在 riscv32—nemu 运行</h3><p>这是一个很简单的异常处理程序，将它编译成 riscv32，并尝试在 nemu 上运行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ make ARCH=riscv32-nemu -j8 run<br></code></pre></td></tr></table></figure><p>就会发现，程序并不能按照想象中的运行，这是因为 nemu 并没有加入指令异常处理机制：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs bash">...<br>invalid opcode(PC = 0x80000044):<br>        00 00 00 00 17 05 00 00 ...<br>        00000000 00000517...<br>There are two cases <span class="hljs-built_in">which</span> will trigger this unexpected exception:<br>1. The instruction at PC = 0x80000044 is not implemented.<br>2. Something is implemented incorrectly.<br>Find this PC(0x80000044) <span class="hljs-keyword">in</span> the disassembling result to distinguish <span class="hljs-built_in">which</span> <span class="hljs-keyword">case</span> it is.<br><br>If it is the first <span class="hljs-keyword">case</span>, see<br>       _                         __  __                         _<br>      (_)                       |  \/  |                       | |<br>  _ __ _ ___  ___ ________   __ | \  / | __ _ _ __  _   _  __ _| |<br> | <span class="hljs-string">&#x27;__| / __|/ __|______\ \ / / | |\/| |/ _` | &#x27;</span>_ \| | | |/ _` | |<br> | |  | \__ \ (__        \ V /  | |  | | (_| | | | | |_| | (_| | |<br> |_|  |_|___/\___|        \_/   |_|  |_|\__,_|_| |_|\__,_|\__,_|_|<br><br><span class="hljs-keyword">for</span> more details.<br><br>If it is the second <span class="hljs-keyword">case</span>, remember:<br>* The machine is always right!<br>* Every line of untested code is always wrong!<br><br>[src/cpu/cpu-exec.c:144 cpu_exec] nemu: ABORT at pc = 0x80000044<br>...<br></code></pre></td></tr></table></figure><p>当程序直行到非法0指令的时候：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs asm">8000002c &lt;main&gt;:<br>8000002c:ff010113          addisp,sp,-16<br>80000030:00112623          swra,12(sp)<br>80000034:00288893          addia7,a7,2<br>80000038:00000797          auipca5,0x0<br>8000003c:fd878793          addia5,a5,-40 # 80000010 &lt;handler&gt;<br>80000040:30579073          csrwmtvec,a5<br>80000044:00000000          .word0x00000000<br>80000048:00000517          auipca0,0x0<br>8000004c:46450513          addia0,a0,1124 # 800004ac &lt;_etext+0x18&gt;<br>80000050:39c000ef          jalra,800003ec &lt;printf&gt;<br>80000054:0000006f          j80000054 &lt;main+0x28&gt;<br></code></pre></td></tr></table></figure><p>nemu 模拟器的处理是老办法，已经很熟悉了。</p><p>但是我想要让这个程序在 nemu 上运行且能正确处理指令异常的话，需要给 nemu 加一点东西。</p><h3 id="指令异常处理"><a href="#指令异常处理" class="headerlink" title="指令异常处理"></a>指令异常处理</h3><p>首先，我们需要将原来的错误指令处理函数修改成这样：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs C">INSTPAT(<span class="hljs-string">&quot;0000000 00001 00000 000 00000 11100 11&quot;</span>, ebreak, N,<br>        NEMUTRAP(s-&gt;pc, R(<span class="hljs-number">10</span>)));  <span class="hljs-comment">// R(10) is $a0</span><br><span class="hljs-comment">// INSTPAT(&quot;??????? ????? ????? ??? ????? ????? ??&quot;, inv, N,</span><br><span class="hljs-comment">// INV(s-&gt;pc));</span><br>INSTPAT(<span class="hljs-string">&quot;??????? ????? ????? ??? ????? ????? ??&quot;</span>, ecall, I,<br>        ECALL(s-&gt;dnpc));  <span class="hljs-comment">// 这里如果指令出现错误，就触发异常</span><br>INSTPAT_END();<br></code></pre></td></tr></table></figure><p>这样，当接受到非法指令的时候，就会发起异常。</p><p>然后我们要需要模拟硬件保存状态寄存器：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">word_t</span> <span class="hljs-title function_">isa_raise_intr</span><span class="hljs-params">(<span class="hljs-type">word_t</span> NO, <span class="hljs-type">vaddr_t</span> epc)</span> &#123;<br>    <span class="hljs-comment">// 实现 etrace</span><br>    IFDEF(CONFIG_ETRACE, etrace(NO, epc));<br>    <span class="hljs-comment">// 在这里决定是否对 pc + 4：</span><br>    <span class="hljs-comment">// 如果是缺页中断: 不加 4；</span><br>    <span class="hljs-comment">// 如果是陷入指令，那么这条指令执行完了自然要执行下一跳指令，+4</span><br>    <span class="hljs-comment">// 如果这里是指令异常，那么应该不 +4，以确保其指向正确的当前指令</span><br>    <span class="hljs-comment">// 非法指令异常号是 2</span><br>    cpu.csr.mcause = NO;<br>    <span class="hljs-keyword">if</span> (NO == <span class="hljs-number">2</span>) &#123;<br>        cpu.csr.mepc = epc;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        cpu.csr.mepc = epc + <span class="hljs-number">4</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> cpu.csr.mtvec;<br>&#125;<br></code></pre></td></tr></table></figure><p>那么这个 NO 怎么来的呢？如果是在 C语言层次发起的异常，比如通过系统调用，那么会自动的调用这yield()：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">void</span> <span class="hljs-title function_">yield</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> __riscv_e</span><br>    <span class="hljs-keyword">asm</span> <span class="hljs-title function_">volatile</span><span class="hljs-params">(<span class="hljs-string">&quot;li a5, -1; ecall&quot;</span>)</span>;<br><span class="hljs-meta">#<span class="hljs-keyword">else</span></span><br>    <span class="hljs-keyword">asm</span> <span class="hljs-title function_">volatile</span><span class="hljs-params">(<span class="hljs-string">&quot;li a7, 11; ecall&quot;</span>)</span>;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>&#125;<br></code></pre></td></tr></table></figure><p>但是上面的例子并不是通过系统调用引发的异常，那应该怎么办呢？我们只需要把上面的程序改造一下，手动给 a7 中写入 2 这个异常类型就好了：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">asm</span> <span class="hljs-title function_">volatile</span><span class="hljs-params">(<span class="hljs-string">&quot;addi a7, a7, 2&quot;</span>)</span>;<br>    <span class="hljs-keyword">asm</span> <span class="hljs-title function_">volatile</span><span class="hljs-params">(<span class="hljs-string">&quot;csrw mtvec, %0&quot;</span> : : <span class="hljs-string">&quot;r&quot;</span>(handler))</span>;<br>    <span class="hljs-keyword">asm</span> <span class="hljs-title function_">volatile</span><span class="hljs-params">(<span class="hljs-string">&quot;.word 0&quot;</span>)</span>;  <span class="hljs-comment">// illegal instruction</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;I am alive!\n&quot;</span>);<br>    <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>)<br>        ;<br>&#125;<br></code></pre></td></tr></table></figure><p>这下就成功了:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash">...<br>bili/异常处理/build/simple-rv-handler-riscv32-nemu.bin, size = 1301<br>[src/monitor/monitor.c:30 welcome] Trace: OFF<br>[src/monitor/monitor.c:36 welcome] Build time: 21:43:22, Nov 21 2024<br>Welcome to riscv32-NEMU!<br>For <span class="hljs-built_in">help</span>, <span class="hljs-built_in">type</span> <span class="hljs-string">&quot;help&quot;</span><br>[src/monitor/monitor.c:40 welcome] Exercise: Please remove me <span class="hljs-keyword">in</span> the <span class="hljs-built_in">source</span> code and compile NEMU again.<br>exception at mepc = 0x80000044<br></code></pre></td></tr></table></figure><p>这样就大功告成了，我们的 mepc 正确指向了错误的指令（不能+4）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs asm">8000002c &lt;main&gt;:<br>8000002c:ff010113          addisp,sp,-16<br>80000030:00112623          swra,12(sp)<br>80000034:00288893          addia7,a7,2<br>80000038:00000797          auipca5,0x0<br>8000003c:fd878793          addia5,a5,-40 # 80000010 &lt;handler&gt;<br>80000040:30579073          csrwmtvec,a5<br>80000044:00000000          .word0x00000000<br>80000048:00000517          auipca0,0x0<br>8000004c:46450513          addia0,a0,1124 # 800004ac &lt;_etext+0x18&gt;<br>80000050:39c000ef          jalra,800003ec &lt;printf&gt;<br>80000054:0000006f          j80000054 &lt;main+0x28&gt;<br></code></pre></td></tr></table></figure><p>解释一下这个程序，就是当遇到非法指令的时候，cpu 应该会自动发起异常，然后由 handler 负责解决异常。</p><p>我在硬件层面模拟了硬件过程（设置 mcause、mepc、mtvec），现在对上面的程序进行修改，我们希望能读出来这三个寄存器的值：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;klib.h&gt;</span></span><br><span class="hljs-type">void</span> <span class="hljs-title function_">handler</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">uintptr_t</span> mepc, mcause, mtvec;<br>    <span class="hljs-keyword">asm</span> <span class="hljs-title function_">volatile</span><span class="hljs-params">(<span class="hljs-string">&quot;csrr %0, mepc&quot;</span> : <span class="hljs-string">&quot;=r&quot;</span>(mepc))</span>;<br>    <span class="hljs-keyword">asm</span> <span class="hljs-title function_">volatile</span><span class="hljs-params">(<span class="hljs-string">&quot;csrr %0, mcause&quot;</span> : <span class="hljs-string">&quot;=r&quot;</span>(mcause))</span>;<br>    <span class="hljs-keyword">asm</span> <span class="hljs-title function_">volatile</span><span class="hljs-params">(<span class="hljs-string">&quot;csrr %0, mtvec&quot;</span> : <span class="hljs-string">&quot;=r&quot;</span>(mtvec))</span>;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;exception at mepc = %p\n&quot;</span>, mepc);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;exception mcause = %p\n&quot;</span>, mcause);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;exception mtvec = %p\n&quot;</span>, mtvec);<br>     <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>);<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">asm</span> <span class="hljs-title function_">volatile</span><span class="hljs-params">(<span class="hljs-string">&quot;addi a7, a7, 2&quot;</span>)</span>;<br>    <span class="hljs-keyword">asm</span> <span class="hljs-title function_">volatile</span><span class="hljs-params">(<span class="hljs-string">&quot;csrw mtvec, %0&quot;</span> : : <span class="hljs-string">&quot;r&quot;</span>(handler))</span>;<br>    <span class="hljs-keyword">asm</span> <span class="hljs-title function_">volatile</span><span class="hljs-params">(<span class="hljs-string">&quot;.word 0&quot;</span>)</span>;  <span class="hljs-comment">// illegal instruction</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;I am alive!\n&quot;</span>);<br>    <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>)<br>        ;<br>&#125;<br></code></pre></td></tr></table></figure><p>编译运行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash">make ARCH=riscv32-nemu -j8 run<br>...<br><br>exception at mepc = 0x80000074<br>exception mcause = 0x2<br>exception mtvec = 0x80000010<br><br></code></pre></td></tr></table></figure><p>对比它的部分反汇编查看：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs asm"><br>80000010 &lt;handler&gt;:<br>80000010:ff010113          addisp,sp,-16<br>80000014:00112623          swra,12(sp)<br>80000018:00812423          sws0,8(sp)<br>8000001c:00912223          sws1,4(sp)<br>80000020:341025f3          csrra1,mepc<br>80000024:342024f3          csrrs1,mcause<br>80000028:30502473          csrrs0,mtvec<br>...<br><br>8000005c &lt;main&gt;:<br>...<br>8000006c:fa878793          addia5,a5,-88 # 80000010 &lt;handler&gt;<br>80000070:30579073          csrwmtvec,a5<br>80000074:00000000          .word0x00000000<br>80000078:00000517          auipca0,0x0<br>...<br></code></pre></td></tr></table></figure><p>也是符合预期的。</p><p>这个是指令异常，指令是 0 指令。假设这个指令问题不大，不会对程序造成任何影响，那么我需要让这个异常处理程序返回到 0 指令的下一条指令，因此这里的 mepc 应该+4。是否+4，完全取决于中断类型。</p><p>那么怎么返回呢？可以将 mepc 的值打到 pc 中，绝对不可以用 ret 指令来返回，因为 ret 是一个伪指令，它实际上是 jalr。在回复上下文后使用 ret，我们的现场就又遭到了破坏（jalr 会修改寄存器），就无法恢复。</p><p>但是我们可以使用 mret，它实际上是将 mepc 拷贝到 pc。</p><p>我们可以在程序中这样操作：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;klib.h&gt;</span></span><br><span class="hljs-type">void</span> <span class="hljs-title function_">handler</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">uintptr_t</span> mepc, mcause, mtvec;<br>    <span class="hljs-keyword">asm</span> <span class="hljs-title function_">volatile</span><span class="hljs-params">(<span class="hljs-string">&quot;csrr %0, mepc&quot;</span> : <span class="hljs-string">&quot;=r&quot;</span>(mepc))</span>;<br>    <span class="hljs-keyword">asm</span> <span class="hljs-title function_">volatile</span><span class="hljs-params">(<span class="hljs-string">&quot;csrr %0, mcause&quot;</span> : <span class="hljs-string">&quot;=r&quot;</span>(mcause))</span>;<br>    <span class="hljs-keyword">asm</span> <span class="hljs-title function_">volatile</span><span class="hljs-params">(<span class="hljs-string">&quot;csrr %0, mtvec&quot;</span> : <span class="hljs-string">&quot;=r&quot;</span>(mtvec))</span>;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;exception at mepc = %p\n&quot;</span>, mepc);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;exception mcause = %p\n&quot;</span>, mcause);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;exception mtvec = %p\n&quot;</span>, mtvec);<br><br>    <span class="hljs-keyword">if</span> (mcause == <span class="hljs-number">2</span>) &#123;<br>        <span class="hljs-keyword">asm</span> <span class="hljs-title function_">volatile</span><span class="hljs-params">(<span class="hljs-string">&quot;csrw mepc, %0;mret&quot;</span> ::<span class="hljs-string">&quot;r&quot;</span>(mepc + <span class="hljs-number">4</span>))</span>; <span class="hljs-comment">//</span><br>    &#125;<br>    <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>)<br>        ;<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">asm</span> <span class="hljs-title function_">volatile</span><span class="hljs-params">(<span class="hljs-string">&quot;addi a7, a7, 2&quot;</span>)</span>;<br>    <span class="hljs-keyword">asm</span> <span class="hljs-title function_">volatile</span><span class="hljs-params">(<span class="hljs-string">&quot;csrw mtvec, %0&quot;</span> : : <span class="hljs-string">&quot;r&quot;</span>(handler))</span>;<br>    <span class="hljs-keyword">asm</span> <span class="hljs-title function_">volatile</span><span class="hljs-params">(<span class="hljs-string">&quot;.word 0&quot;</span>)</span>;  <span class="hljs-comment">// illegal instruction</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;I am alive!\n&quot;</span>);<br>    <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>)<br>        ;<br>&#125;<br></code></pre></td></tr></table></figure><p>当 mcause 为 2 的时候，我们再执行两条指令，分别是修改 mepc，以及 mret。编译运行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash">make ARCH=riscv32-nemu -j8 run<br>...<br><br>exception at mepc = 0x80000094<br>exception mcause = 0x2<br>exception mtvec = 0x80000010<br>I am alive!<br><br></code></pre></td></tr></table></figure><p>当然这种返回不符合规范，因为它没有保存、恢复上下文。正常的异常处理调用 handler 之前，需要保存现场，然后返回到 handler，然后再恢复现场，最后调用 mret。</p><h2 id="系统调用"><a href="#系统调用" class="headerlink" title="系统调用"></a>系统调用</h2><p>CPU 的特权级（riscv）：</p><ul><li>M: 机器模式</li><li>S: 监管模式</li><li>U: 用户模式</li></ul><p>怎么管理呢？不是任何程序都能随便指令危险的指令比如内联汇编中操作 csr 寄存器。这个解决方案是由硬件提供的，之前在 nemu 中跑上面的例子，都是以 M 模式直接跑的，真实环境下是不行的。</p><p>比如下面这个例子：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> csr;<br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> __riscv</span><br>    <span class="hljs-keyword">asm</span> <span class="hljs-title function_">volatile</span><span class="hljs-params">(<span class="hljs-string">&quot;csrr %0, mepc&quot;</span> : <span class="hljs-string">&quot;=r&quot;</span>(csr))</span>;<br><span class="hljs-meta">#<span class="hljs-keyword">else</span>  <span class="hljs-comment">// x86</span></span><br>    <span class="hljs-keyword">asm</span> <span class="hljs-title function_">volatile</span><span class="hljs-params">(<span class="hljs-string">&quot;mov %%cr0, %0&quot;</span> : <span class="hljs-string">&quot;=r&quot;</span>(csr))</span>;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;csr = %p\n&quot;</span>, csr);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>这个程序不管是 riscv 还是 x86 都在尝试执行非法指令，我们先在 rv64 中跑：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ rv64gcc test.c<br>$ ./a.out<br>[1]    248701 illegal hardware instruction (core dumped)  ./a.out<br></code></pre></td></tr></table></figure><p>可以看到，它报错，显示非法指令。继续在 x86 上跑：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ gcc test.c<br>$ ./a.out<br>[1]    248889 segmentation fault (core dumped)  ./a.out<br></code></pre></td></tr></table></figure><p>x86 的报错是段错误，也是一样的，因为寄存器地址非法。</p><p>修改程序，让其执行U模式下可以执行的指令：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> a0;<br>    <span class="hljs-keyword">asm</span> <span class="hljs-title function_">volatile</span><span class="hljs-params">(</span><br><span class="hljs-params">        <span class="hljs-string">&quot;li a0, 10\n&quot;</span></span><br><span class="hljs-params">        <span class="hljs-string">&quot;mv %0, a0&quot;</span></span><br><span class="hljs-params">        : <span class="hljs-string">&quot;=r&quot;</span>(a0)</span><br><span class="hljs-params">        :</span><br><span class="hljs-params">        : <span class="hljs-string">&quot;a0&quot;</span>)</span>;<br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;a0 = %x\n&quot;</span>, a0);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>运行就很正常：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ rv64gcc test.c<br>$ ./a.out<br>a0 = a<br></code></pre></td></tr></table></figure><p>一般规定，资源管理程序放在高特权级（S），这实际上就是操作系统的代码；用户程序运行在低特权级（U），比如普通运算，发起系统调用请求等。</p><p>那么怎么发起一个系统调用呢？唯一合法方式：自陷类异常-执行一条无条件触发异常的指令。riscv 提供了 ecall 指令，操作系统从而可以根据这个 ecall 指令，去审查 mcause 判断该异常的来源。比如在 U 模式下发起的 ecall，mcause 为 8；在 S 模式下发起的 ecall，mcause 为 9；在 M 模式下发起 ecall，mcause 为 10。</p><p>当发起 ecall 的时候，OS 会检查 mcause，从而判断是否合法；如果合法。就会出处理这个 ecall。具体就是保存上下文、返回到 handler，handler 处理完后恢复现场，然后 mret。</p><p>当然，请求系统调用需要给系统传参，告诉操作系统我需要何种服务。最合理的方式是通过寄存器来传参。约定：a7 传递系统调用号码。</p><p>一个例子：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Hello World!\n&quot;</span>);<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>在 rv64 平台下运行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ rv64gcc hello.c<br>$ ./a.out<br>Hello World!<br></code></pre></td></tr></table></figure><p>我们想知道它在运行的时候的 trace，比如 strace，这时候加上一些参数：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ qemu-riscv64 -d strace,trace:guest_user_syscall a.out<br>...<br>guest_user_syscall cpu=0x55afcb4bf7e0 num=0x0000000000000040 arg1=0x0000000000000001 arg2=0x00000040000032a0 arg3=0x000000000000000d arg4=0x00000040000032a0 arg5=0x0000000000000000 arg6=0x0000000000000000 arg7=0x0000000000000000 arg8=0x0000000000000000<br>250892 write(1,0x32a0,13)Hello World!<br> = 13<br>...<br></code></pre></td></tr></table></figure><p>可以看到，printf 其实就是一个系统调用 write：第一个参数为文件描述符 1，说明是标准输出；第二个参数为缓冲区地址0x32a0，第三个参数为字符长度，刚好是 13。</p><p>可以看手册：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs bash">man 2 write<br>...<br>NAME<br>       write - write to a file descriptor<br><br>SYNOPSIS<br>       <span class="hljs-comment">#include &lt;unistd.h&gt;</span><br><br>       ssize_t write(int fd, const void *buf, size_t count);<br><br>DESCRIPTION<br>       write()  writes up to count bytes from the buffer starting at buf to the file referred to by the file<br>       descriptor fd.<br>...<br><br></code></pre></td></tr></table></figure><p>通过上面的 trace，可以看到这个系统调用的调用号为 num &#x3D; 0x40，那么我们就可以通过汇编来发起系统调用了：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>  <span class="hljs-keyword">asm</span> <span class="hljs-title function_">volatile</span> <span class="hljs-params">(</span><br><span class="hljs-params">      <span class="hljs-string">&quot;li a0, 1\n&quot;</span></span><br><span class="hljs-params">      <span class="hljs-string">&quot;mv a1, %0\n&quot;</span></span><br><span class="hljs-params">      <span class="hljs-string">&quot;mv a2, %1\n&quot;</span></span><br><span class="hljs-params">      <span class="hljs-string">&quot;li a7, 0x40\n&quot;</span></span><br><span class="hljs-params">      <span class="hljs-string">&quot;ecall\n&quot;</span></span><br><span class="hljs-params">      : : <span class="hljs-string">&quot;r&quot;</span>(<span class="hljs-string">&quot;Hello World_Hello world!\n&quot;</span>), <span class="hljs-string">&quot;r&quot;</span>(<span class="hljs-number">26</span>))</span>;<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>编译运行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ rv64gcc a.c<br>$ ./a.out<br>Hello World_Hello world!<br></code></pre></td></tr></table></figure><p>通过 trace 可以发现，几乎一摸一样：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">guest_user_syscall cpu=0x629597e6b7a0 num=0x0000000000000040 arg1=0x0000000000000001 arg2=0x0000004000000658 arg3=0x000000000000001a arg4=0x0000000000000000 arg5=0x000000000000001a arg6=0x0000004000000658 arg7=0x0000000000000000 arg8=0x0000000000000000<br>252231 write(1,0x658,26)Hello World_Hello world!<br> = 26<br></code></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;span id=&quot;more&quot;&gt;&lt;/span&gt;

&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;阅读本案例需要有做 nemu 的经历，最低要求是是做到 PA3.1。&lt;/p&gt;
&lt;h2 id</summary>
      
    
    
    
    <category term="ysyx" scheme="http://blog.luliang.online/categories/ysyx/"/>
    
    
    <category term="异常处理" scheme="http://blog.luliang.online/tags/%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>总线</title>
    <link href="http://blog.luliang.online/2024/10/30/%E6%80%BB%E7%BA%BF/"/>
    <id>http://blog.luliang.online/2024/10/30/%E6%80%BB%E7%BA%BF/</id>
    <published>2024-10-30T13:20:40.000Z</published>
    <updated>2025-02-18T13:55:24.289Z</updated>
    
    <content type="html"><![CDATA[<span id="more"></span><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>1、将默认信号改成握手信号<br>2、加上随机延迟<br>3、综合测试</p><p>状态机的角度进行思考，如何进行状态转换，这个过程中，要考虑信号延迟，因此要能将状态能够保持几个周期，因此要在信号发射端，保持这些信号。总之，谁发射，谁负责，谁接收到了，谁转换状态。</p><p>CPU 的状态完全靠寄存器来保持；MEM 的状态完全靠寄存器来保持。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;span id=&quot;more&quot;&gt;&lt;/span&gt;

&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;h3 id=&quot;思路&quot;&gt;&lt;a href=&quot;#思路&quot; class=&quot;headerlink&quot; tit</summary>
      
    
    
    
    <category term="ysyx" scheme="http://blog.luliang.online/categories/ysyx/"/>
    
    <category term="npc" scheme="http://blog.luliang.online/categories/ysyx/npc/"/>
    
    
    <category term="ysyx" scheme="http://blog.luliang.online/tags/ysyx/"/>
    
    <category term="总线" scheme="http://blog.luliang.online/tags/%E6%80%BB%E7%BA%BF/"/>
    
  </entry>
  
  <entry>
    <title>AXI总线协议简述</title>
    <link href="http://blog.luliang.online/2024/10/28/AXI%E6%80%BB%E7%BA%BF%E5%8D%8F%E8%AE%AE/"/>
    <id>http://blog.luliang.online/2024/10/28/AXI%E6%80%BB%E7%BA%BF%E5%8D%8F%E8%AE%AE/</id>
    <published>2024-10-28T13:20:40.000Z</published>
    <updated>2025-02-18T13:55:24.270Z</updated>
    
    <content type="html"><![CDATA[<span id="more"></span><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>AXI（<strong>Advanced eXtensible Interface</strong>）是 <strong>AMBA</strong>（Advanced Microcontroller Bus Architecture）协议家族的一部分，由 <strong>ARM</strong> 公司制定。AXI 是一种高性能、可扩展的总线协议，广泛用于 <strong>SoC（System on Chip）</strong> 设计中，特别适用于高带宽、低延迟的应用。它主要用于在系统中不同组件之间传输数据和控制信号，尤其是 CPU、内存、外设之间的通信。</p><p>AXI 协议的特点是支持 <strong>高吞吐量</strong> 和 <strong>低延迟</strong> 的数据传输，具备 <strong>多主多从结构</strong>，并且支持 <strong>独立的读写通道</strong>，从而提高总线的效率。下面是对 AXI 协议的详细介绍。</p><h3 id="AXI-总线的核心特性"><a href="#AXI-总线的核心特性" class="headerlink" title="AXI 总线的核心特性"></a>AXI 总线的核心特性</h3><ol><li><p><strong>独立的读写通道</strong>：<br>AXI 协议将读操作和写操作分成了两个完全独立的通道，分别通过 <strong>读通道</strong> 和 <strong>写通道</strong> 传输。这意味着读和写操作可以同时进行，彼此互不干扰，极大提高了系统的吞吐量和性能。</p></li><li><p><strong>握手机制</strong>：<br>AXI 使用 <code>valid</code> 和 <code>ready</code> 信号来协调数据的传输，确保发送方和接收方在数据传输前都准备好。<code>valid</code> 信号表明数据有效，<code>ready</code> 信号表明接收方准备好接受数据，只有两者同时为高电平时，数据传输才会进行。这种握手机制保证了通信的可靠性和同步性。</p></li><li><p><strong>地址与数据分离</strong>：<br>AXI 协议将地址和数据分为不同的信号通道，地址的传输与数据的传输是独立的。它采用<strong>地址提前机制</strong>，即地址通道先行，数据通道随后，这种设计减少了数据传输的等待时间。</p></li><li><p><strong>突发传输</strong>（Burst Transfer）：<br>AXI 支持突发传输，一次传输可以连续发送多笔数据，且这些数据共享同一个起始地址。突发传输有三种类型：</p><ul><li><strong>固定突发</strong>：每次传输的地址保持不变。</li><li><strong>递增突发</strong>：每次传输的地址递增。</li><li><strong>包装突发</strong>：地址以固定的包长度循环变化。</li></ul></li><li><p><strong>低延迟高带宽</strong>：<br>AXI 协议通过分离地址和数据通道、独立的读写通道，以及支持突发传输的特性，能够提供低延迟和高带宽的数据传输能力。</p></li></ol><h3 id="AXI-通道"><a href="#AXI-通道" class="headerlink" title="AXI 通道"></a>AXI 通道</h3><p>AXI 协议将总线操作分为以下 <strong>5 个独立的通道</strong>：</p><ol><li><p><strong>读地址通道</strong>（Read Address Channel）：</p><ul><li>用于发送读操作的地址。</li><li>信号主要有：<code>ARADDR</code>（读地址）、<code>ARVALID</code>（地址有效信号）、<code>ARREADY</code>（地址准备好信号）等。</li></ul></li><li><p><strong>读数据通道</strong>（Read Data Channel）：</p><ul><li>用于从从设备返回读操作的数据。</li><li>信号主要有：<code>RDATA</code>（读数据）、<code>RVALID</code>（数据有效信号）、<code>RREADY</code>（接收端准备好信号）、<code>RRESP</code>（读响应）等。</li></ul></li><li><p><strong>写地址通道</strong>（Write Address Channel）：</p><ul><li>用于发送写操作的地址。</li><li>信号主要有：<code>AWADDR</code>（写地址）、<code>AWVALID</code>（地址有效信号）、<code>AWREADY</code>（地址准备好信号）等。</li></ul></li><li><p><strong>写数据通道</strong>（Write Data Channel）：</p><ul><li>用于发送写操作的数据。</li><li>信号主要有：<code>WDATA</code>（写数据）、<code>WSTRB</code>（写数据的字节掩码）、<code>WVALID</code>（数据有效信号）、<code>WREADY</code>（接收端准备好信号）等。</li></ul></li><li><p><strong>写响应通道</strong>（Write Response Channel）：</p><ul><li>用于从从设备返回写操作的结果。</li><li>信号主要有：<code>BVALID</code>（写响应有效信号）、<code>BREADY</code>（接收端准备好信号）、<code>BRESP</code>（写响应信号）等。</li></ul></li></ol><h3 id="AXI-信号详细说明"><a href="#AXI-信号详细说明" class="headerlink" title="AXI 信号详细说明"></a>AXI 信号详细说明</h3><p>每个通道都使用 <code>VALID</code> 和 <code>READY</code> 信号来进行握手，确保主设备和从设备双方都准备好进行数据传输。</p><ul><li><strong>VALID</strong>：发送方用来指示当前信号有效。</li><li><strong>READY</strong>：接收方用来指示它准备好接收数据。</li></ul><p>当 <code>VALID</code> 和 <code>READY</code> 同时为高时，数据或地址才能传输。下面是每个通道的具体信号：</p><ol><li><p>**读地址通道 (Read Address Channel)**：</p><ul><li><code>ARADDR</code>：读地址。</li><li><code>ARVALID</code>：读地址有效。</li><li><code>ARREADY</code>：从设备准备好接收地址。</li></ul></li><li><p>**读数据通道 (Read Data Channel)**：</p><ul><li><code>RDATA</code>：读数据。</li><li><code>RVALID</code>：数据有效。</li><li><code>RREADY</code>：主设备准备好接收数据。</li><li><code>RRESP</code>：读响应（通常表示是否读取成功，如 <code>OKAY</code>，<code>SLVERR</code>，<code>DECERR</code>）。</li></ul></li><li><p>**写地址通道 (Write Address Channel)**：</p><ul><li><code>AWADDR</code>：写地址。</li><li><code>AWVALID</code>：写地址有效。</li><li><code>AWREADY</code>：从设备准备好接收地址。</li></ul></li><li><p>**写数据通道 (Write Data Channel)**：</p><ul><li><code>WDATA</code>：写数据。</li><li><code>WSTRB</code>：写数据的字节掩码，用来指示哪些字节有效。</li><li><code>WVALID</code>：数据有效。</li><li><code>WREADY</code>：从设备准备好接收数据。</li></ul></li><li><p>**写响应通道 (Write Response Channel)**：</p><ul><li><code>BRESP</code>：写响应，表示写入操作的状态（如 <code>OKAY</code>，<code>SLVERR</code>）。</li><li><code>BVALID</code>：写响应有效。</li><li><code>BREADY</code>：主设备准备好接收写响应。</li></ul></li></ol><h3 id="典型-AXI-读写操作流程"><a href="#典型-AXI-读写操作流程" class="headerlink" title="典型 AXI 读写操作流程"></a>典型 AXI 读写操作流程</h3><h4 id="读操作流程："><a href="#读操作流程：" class="headerlink" title="读操作流程："></a>读操作流程：</h4><ol><li>主设备发送读地址 (<code>ARADDR</code>) 并通过 <code>ARVALID</code> 表示地址有效。</li><li>从设备通过 <code>ARREADY</code> 表示准备好接收地址。</li><li>从设备准备好数据，并通过 <code>RVALID</code> 表示数据有效。</li><li>主设备通过 <code>RREADY</code> 表示准备好接收数据。</li><li>数据传输完成后，从设备通过 <code>RRESP</code> 发送读响应。</li></ol><h4 id="写操作流程："><a href="#写操作流程：" class="headerlink" title="写操作流程："></a>写操作流程：</h4><ol><li>主设备发送写地址 (<code>AWADDR</code>) 并通过 <code>AWVALID</code> 表示地址有效。</li><li>从设备通过 <code>AWREADY</code> 表示准备好接收地址。</li><li>主设备发送写数据 (<code>WDATA</code>) 并通过 <code>WVALID</code> 表示数据有效。</li><li>从设备通过 <code>WREADY</code> 表示准备好接收数据。</li><li>数据写入后，从设备通过 <code>BVALID</code> 发送写响应，主设备通过 <code>BREADY</code> 接收响应。</li></ol><h3 id="AXI-突发传输"><a href="#AXI-突发传输" class="headerlink" title="AXI 突发传输"></a>AXI 突发传输</h3><p>AXI 支持突发传输，可以在一次请求中传输多个数据包，从而提高效率。突发传输可以是<strong>固定突发</strong>（地址不变）、<strong>递增突发</strong>（地址递增）或<strong>包装突发</strong>（地址循环变化）。</p><h3 id="AXI-总线的应用场景"><a href="#AXI-总线的应用场景" class="headerlink" title="AXI 总线的应用场景"></a>AXI 总线的应用场景</h3><p>AXI 协议由于其高效的数据传输机制和多通道支持，广泛应用于各种 SoC 设计中，特别是在需要高带宽、低延迟的场景下，例如：</p><ul><li>CPU 和内存的交互。</li><li>高性能外设（如 DMA、GPU）和系统总线之间的数据传输。</li><li>多核处理器和共享内存之间的通信。</li></ul><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>AXI 总线协议提供了强大的高性能通信机制，支持多主多从、突发传输、独立的读写通道，并通过握手机制确保数据传输的同步和可靠性。AXI 是现代 SoC 设计中重要的基础技术，被广泛应用于各种高带宽、低延迟的数据传输场景。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;span id=&quot;more&quot;&gt;&lt;/span&gt;

&lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;AXI（&lt;strong&gt;Advanced eXtensible Interface&lt;/st</summary>
      
    
    
    
    <category term="ysyx" scheme="http://blog.luliang.online/categories/ysyx/"/>
    
    <category term="npc" scheme="http://blog.luliang.online/categories/ysyx/npc/"/>
    
    
    <category term="ysyx" scheme="http://blog.luliang.online/tags/ysyx/"/>
    
    <category term="总线" scheme="http://blog.luliang.online/tags/%E6%80%BB%E7%BA%BF/"/>
    
  </entry>
  
  <entry>
    <title>RT-Thread in PA4.1 的思考</title>
    <link href="http://blog.luliang.online/2024/10/21/RT-Thread/"/>
    <id>http://blog.luliang.online/2024/10/21/RT-Thread/</id>
    <published>2024-10-21T14:20:40.000Z</published>
    <updated>2025-02-18T13:55:24.278Z</updated>
    
    <content type="html"><![CDATA[<span id="more"></span><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>前面谈到了异常响应机制，如果在上下文恢复的时候，做点手脚，比如别让它回到原来的上下文，而是回到了另一个进程的上下文，那么这就是进程切换，也是多道程序的基础。</p><h2 id="yield-OS"><a href="#yield-OS" class="headerlink" title="yield OS"></a>yield OS</h2><p>前言就是 yield OS 的核心思想了，实现kcontext 后，别忘了修改 trap.S，使得 a0 这个返回值传到 sp。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs C">Context* <span class="hljs-title function_">kcontext</span><span class="hljs-params">(Area kstack, <span class="hljs-type">void</span> (*entry)(<span class="hljs-type">void</span>*), <span class="hljs-type">void</span>* arg)</span> &#123;<br><br>    Context* ctp = (Context*)kstack.end - <span class="hljs-number">1</span>; <span class="hljs-comment">// 开辟空间</span><br>    ctp-&gt;gpr[<span class="hljs-number">10</span>] = (<span class="hljs-type">uintptr_t</span>)arg;  <span class="hljs-comment">// 传参到 a0</span><br>    ctp-&gt;mepc = (<span class="hljs-type">uintptr_t</span>)entry;<br>    <span class="hljs-keyword">return</span> ctp;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="RT-Thread"><a href="#RT-Thread" class="headerlink" title="RT-Thread"></a>RT-Thread</h2><p>这个 RT-Thread 真不好啃，喝了一杯浓咖啡，直接从 中午不到 12 点弄到了晚上 6:50，我觉得主要问题是不熟悉RT-Thread 执行的整个流程，对讲义理解的不到位。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">rt_uint8_t</span> *<span class="hljs-title function_">rt_hw_stack_init</span><span class="hljs-params">(<span class="hljs-type">void</span> *tentry, <span class="hljs-type">void</span> *parameter, <span class="hljs-type">rt_uint8_t</span> *stack_addr, <span class="hljs-type">void</span> *texit)</span>;<br></code></pre></td></tr></table></figure><p>这个函数本来很简单，但是它的功能属实太刁难人了，如果只是 以stack_addr 为栈底创建一个入口为 tentry，参数为parameter的上下文， 并返回这个上下文结构的指针。那么就很简单：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">rt_uint8_t</span>* <span class="hljs-title function_">rt_hw_stack_init</span><span class="hljs-params">(<span class="hljs-type">void</span>* tentry,</span><br><span class="hljs-params">                             <span class="hljs-type">void</span>* parameter,</span><br><span class="hljs-params">                             <span class="hljs-type">rt_uint8_t</span>* stack_addr,</span><br><span class="hljs-params">                             <span class="hljs-type">void</span>* texit)</span> &#123;<br><br>    stack_addr = (<span class="hljs-type">rt_uint8_t</span>*)(((<span class="hljs-type">uintptr_t</span>)stack_addr + <span class="hljs-keyword">sizeof</span>(<span class="hljs-type">uintptr_t</span>) - <span class="hljs-number">1</span>) &amp;<br>                               ~(<span class="hljs-keyword">sizeof</span>(<span class="hljs-type">uintptr_t</span>) - <span class="hljs-number">1</span>));<br><br><br>    Area stack_area = &#123;.end = (<span class="hljs-type">rt_uint8_t</span>*)stack_addr&#125;;<br>    <span class="hljs-type">rt_uint8_t</span>* c =<br>        (<span class="hljs-type">rt_uint8_t</span>*)kcontext(stack_area, tentry, parameter);<br><br>    <span class="hljs-keyword">return</span> c;<br>&#125;<br></code></pre></td></tr></table></figure><p>但是，这里要求：若上下文对应的内核线程从 tentry 返回， 则调用 texit，RT-Thread会保证代码不会从 texit 中返回。这就复杂了，”一种方式是构造一个包裹函数, 让包裹函数来调用tentry, 并在tentry返回后调用texit, 然后将这个包裹函数作为kcontext()的真正入口, 不过这还要求我们将tentry, parameter和texit这三个参数传给包裹函数, 应该如何解决这个传参问题呢?”</p><p>我的想法是，只要将这个 mepc 直接指向 Wrapper_Func 就行了，参数传递过去就是 C 语言编程问题了。<br>首先实现参数结构体：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br>    <span class="hljs-type">void</span> (*tentry)(<span class="hljs-type">void</span>*);<br>    <span class="hljs-type">void</span>* parameter;<br>    <span class="hljs-type">void</span> (*texit)(<span class="hljs-type">void</span>);<br>&#125; <span class="hljs-type">thread_args_t</span>;<br></code></pre></td></tr></table></figure><p>然后就是 Wrapper_Func:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">context_wrapper</span><span class="hljs-params">(<span class="hljs-type">thread_args_t</span>* args)</span> &#123;<br>    args-&gt;tentry(args-&gt;parameter);<br>    args-&gt;texit();<br><br>    <span class="hljs-comment">// 不应该执行于此，RT_Thread 保证了 texit() 不会退出</span><br>    <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>)<br>        ;<br>&#125;<br></code></pre></td></tr></table></figure><p>然后，就是对它的改造了：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs C"><br><span class="hljs-type">rt_uint8_t</span>* <span class="hljs-title function_">rt_hw_stack_init</span><span class="hljs-params">(<span class="hljs-type">void</span>* tentry,</span><br><span class="hljs-params">                             <span class="hljs-type">void</span>* parameter,</span><br><span class="hljs-params">                             <span class="hljs-type">rt_uint8_t</span>* stack_addr,</span><br><span class="hljs-params">                             <span class="hljs-type">void</span>* texit)</span> &#123;<br><br>    stack_addr = (<span class="hljs-type">rt_uint8_t</span>*)(((<span class="hljs-type">uintptr_t</span>)stack_addr + <span class="hljs-keyword">sizeof</span>(<span class="hljs-type">uintptr_t</span>) - <span class="hljs-number">1</span>) &amp;<br>                               ~(<span class="hljs-keyword">sizeof</span>(<span class="hljs-type">uintptr_t</span>) - <span class="hljs-number">1</span>));<br><br><br>    stack_addr -= <span class="hljs-keyword">sizeof</span>(<span class="hljs-type">thread_args_t</span>); <span class="hljs-comment">// 在栈上分配参数结构体空间</span><br>    <span class="hljs-type">thread_args_t</span>* args = (<span class="hljs-type">thread_args_t</span>*)stack_addr; <span class="hljs-comment">// 转型</span><br><br>    <span class="hljs-comment">// 设置参数</span><br>    args-&gt;tentry = (<span class="hljs-type">void</span> (*)(<span class="hljs-type">void</span>*))tentry;<br>    args-&gt;parameter = parameter;<br>    args-&gt;texit = (<span class="hljs-type">void</span> (*)(<span class="hljs-type">void</span>))texit;<br><br>    Area stack_area = &#123;.end = (<span class="hljs-type">rt_uint8_t</span>*)stack_addr&#125;;  <span class="hljs-comment">// 设置栈区域</span><br>    <span class="hljs-type">rt_uint8_t</span>* c =<br>        (<span class="hljs-type">rt_uint8_t</span>*)kcontext(stack_area, (<span class="hljs-type">void</span>*)context_wrapper, args);<br><br>    <span class="hljs-keyword">return</span> c;<br>&#125;<br></code></pre></td></tr></table></figure><p>完美。</p><p>还有两个函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">void</span> <span class="hljs-title function_">rt_hw_context_switch_to</span><span class="hljs-params">(<span class="hljs-type">rt_ubase_t</span> to)</span>;<br><span class="hljs-type">void</span> <span class="hljs-title function_">rt_hw_context_switch</span><span class="hljs-params">(<span class="hljs-type">rt_ubase_t</span> from, <span class="hljs-type">rt_ubase_t</span> to)</span>;<br></code></pre></td></tr></table></figure><p>这两个函数的功能几乎一样。难点是，我们要传参，但是切换上下文的动作其实是 yield 之后。在事件处理回调函数ev_handler()中识别出 EVENT_YIELD 事件后, 再返回 to，顺便处理 from。</p><p>但是，ev_handler()长这个样子：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">static</span> Context* <span class="hljs-title function_">ev_handler</span><span class="hljs-params">(Event e, Context* c)</span> &#123;<br>    <span class="hljs-type">rt_ubase_t</span>* para;<br>    <span class="hljs-keyword">switch</span> (e.event) &#123;<br>        <span class="hljs-keyword">default</span>:<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Unhandled event ID = %d\n&quot;</span>, e.event);<br>            assert(<span class="hljs-number">0</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> c;<br>&#125;<br></code></pre></td></tr></table></figure><p>很明显，它没有直接驾驭 to、from 的手段。怎么办？我们可以借助全局变量，，，，这是一种下乘的手段。类似于这样：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">rt_ubase_t</span> g_to,g_from;<br><span class="hljs-type">static</span> Context* <span class="hljs-title function_">ev_handler</span><span class="hljs-params">(Event e, Context* c)</span> &#123;<br>    <span class="hljs-keyword">switch</span> (e.event) &#123;<br>        <span class="hljs-keyword">case</span> EVENT_YIELD:<br>            <span class="hljs-keyword">if</span> (from) &#123;<br>                *((Context**)from) = c;<br>            &#125;<br>            c = *(Context**)to;  <span class="hljs-comment">// 解引用，拿到一级指针</span><br>            <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">default</span>:<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Unhandled event ID = %d\n&quot;</span>, e.event);<br>            assert(<span class="hljs-number">0</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> c;<br>&#125;<br></code></pre></td></tr></table></figure><p>swicth:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">void</span> <span class="hljs-title function_">rt_hw_context_switch_to</span><span class="hljs-params">(<span class="hljs-type">rt_ubase_t</span> to)</span> &#123;<br>    g_to = to;<br>    yield();<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">rt_hw_context_switch</span><span class="hljs-params">(<span class="hljs-type">rt_ubase_t</span> from, <span class="hljs-type">rt_ubase_t</span> to)</span> &#123;<br>    g_to = to;<br>    g_from = from;<br>    yield();<br>&#125;<br></code></pre></td></tr></table></figure><p>是不是很丑陋？能跑吗？能跑：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><code class="hljs Bash">am-apps.data.size = d, am-apps.bss.size = d<br>heap: [0x80156000 - 0x88000000]<br><br> \ | /<br>- RT -     Thread Operating System<br> / | \     5.0.1 build Oct 21 2024 21:55:52<br> 2006 - 2022 Copyright by RT-Thread team<br>[I/utest] utest is initialize success.<br>[I/utest] total utest testcase num: (0)<br>Hello RISC-V!<br>msh /&gt;<span class="hljs-built_in">help</span><br>RT-Thread shell commands:<br><span class="hljs-built_in">date</span>             - get <span class="hljs-built_in">date</span> and time or <span class="hljs-built_in">set</span> (<span class="hljs-built_in">local</span> timezone) [year month day hour min sec]<br>list             - list objects<br>version          - show RT-Thread version information<br>clear            - clear the terminal screen<br>free             - Show the memory usage <span class="hljs-keyword">in</span> the system.<br>ps               - List threads <span class="hljs-keyword">in</span> the system.<br><span class="hljs-built_in">help</span>             - RT-Thread shell <span class="hljs-built_in">help</span>.<br><span class="hljs-built_in">tail</span>             - <span class="hljs-built_in">print</span> the last N - lines data of the given file<br><span class="hljs-built_in">echo</span>             - <span class="hljs-built_in">echo</span> string to file<br><span class="hljs-built_in">df</span>               - disk free<br>umount           - Unmount the mountpoint<br>mount            - mount &lt;device&gt; &lt;mountpoint&gt; &lt;fstype&gt;<br>mkfs             - format disk with file system<br><span class="hljs-built_in">mkdir</span>            - Create the DIRECTORY.<br><span class="hljs-built_in">pwd</span>              - Print the name of the current working directory.<br><span class="hljs-built_in">cd</span>               - Change the shell working directory.<br><span class="hljs-built_in">rm</span>               - Remove(<span class="hljs-built_in">unlink</span>) the FILE(s).<br><span class="hljs-built_in">cat</span>              - Concatenate FILE(s)<br><span class="hljs-built_in">mv</span>               - Rename SOURCE to DEST.<br><span class="hljs-built_in">cp</span>               - Copy SOURCE to DEST.<br><span class="hljs-built_in">ls</span>               - List information about the FILEs.<br>utest_run        - utest_run [-thread or -<span class="hljs-built_in">help</span>] [testcase name] [loop num]<br>utest_list       - output all utest testcase<br>memtrace         - dump memory trace information<br>memcheck         - check memory data<br>am_fceux_am      - AM fceux_am<br>am_snake         - AM snake<br>am_typing_game   - AM typing_game<br>am_microbench    - AM microbench<br>am_hello         - AM hello<br><br>msh /&gt;<span class="hljs-built_in">date</span><br>[W/time] Cannot find a RTC device!<br><span class="hljs-built_in">local</span> time: Thu Jan  1 08:00:00 1970<br>timestamps: 0<br>timezone: UTC+8<br>msh /&gt;version<br><br> \ | /<br>- RT -     Thread Operating System<br> / | \     5.0.1 build Oct 21 2024 21:55:52<br> 2006 - 2022 Copyright by RT-Thread team<br>msh /&gt;free<br>total    : 132816792<br>used     : 33583304<br>maximum  : 33583304<br>available: 99233488<br>msh /&gt;ps<br>thread                   pri  status      sp     stack size max used left tick  error<br>------------------------ ---  ------- ---------- ----------  ------  ---------- ---<br>tshell                    20  running 0x000000a0 0x00001000    21%   0x0000000a OK<br>sys workq                 23  ready   0x000000a0 0x00002000    01%   0x0000000a OK<br>tidle0                    31  ready   0x000000a0 0x00004000    00%   0x00000020 OK<br>timer                      4  <span class="hljs-built_in">suspend</span> 0x000000f0 0x00004000    01%   0x0000000a OK<br>main                      10  close   0x000000e0 0x00000800    19%   0x00000014 OK<br>msh /&gt;<span class="hljs-built_in">pwd</span><br>/<br>msh /&gt;<span class="hljs-built_in">ls</span><br>No such directory<br>msh /&gt;memtrace<br><br>memory heap address:<br>name    : heap<br>total   : 0x132816792<br>used    : 0x33583304<br>max_used: 0x33583336<br>heap_ptr: 0x80156048<br>lfree   : 0x8215d110<br>heap_end: 0x87fffff0<br><br>--memory item information --<br>[0x80156048 -   32M] NONE<br>[0x82156058 -   12K] NONE<br>[0x82159260 -   176] NONE<br>[0x82159320 -    2K] NONE<br>[0x82159b30 -    16] main<br>[0x82159b50 -    72] main<br>[0x82159ba8 -   176] main<br>[0x82159c68 -    8K] main<br>[0x8215bc78 -   952] main<br>[0x8215c040 -   176] main<br>[0x8215c100 -    4K] main<br>[0x8215d110 -   94M]<br>msh /&gt;memcheck<br>msh /&gt;utest_list<br>[I/utest] Commands list :<br>msh /&gt;<br></code></pre></td></tr></table></figure><p>但是，讲义不断强调，这很危险，尤其是多线程的时候。能跑只是因为nemu 是单线程，运气罢了。</p><p>怎么改？讲义给了提示：</p><p>&#96;能否不使用全局变量来实现上下文的切换呢?</p><p>同样地, 我们需要寻找一种不会被多个线程共享的存储空间. 不过对于调用rt_hw_context_switch()的线程来说, 它的栈正在被使用, 往其中写入数据可能会被覆盖, 甚至可能会覆盖已有数据, 使当前线程崩溃. to的栈虽然当前不使用, 也不会被其他线程共享, 但需要考虑如何让ev_handler()访问到to的栈, 这又回到了我们一开始想要解决的问题.</p><p>除了栈之外, 还有没有其他不会被多个线程共享的存储空间呢? 嘿嘿, 其实前文也已经提到过它了, 那就是PCB! 因为每个线程对应一个PCB, 而一个线程不会被同时调度多次, 所以通过PCB来传递信息也是一个可行的方案. 要获取当前线程的PCB, 自然是用current指针了.</p><p>在RT-Thread中, 可以通过调用rt_thread_self()返回当前线程的PCB. 阅读RT-Thread中PCB结构体的定义, 我们发现其中有一个成员user_data, 它用于存放线程的私有数据, 这意味着RT-Thread中调度相关的代码必定不会使用这个成员, 因此它很适合我们用来传递信息. 不过为了避免覆盖user_data中的已有数据, 我们可以先把它保存在一个临时变量中, 在下次切换回当前线程并从rt_hw_context_switch()返回之前再恢复它. 至于这个临时变量, 当然是使用局部变量了, 毕竟局部变量是在栈上分配的, 完美!&#96;</p><p>不错的方法：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">static</span> Context* <span class="hljs-title function_">ev_handler</span><span class="hljs-params">(Event e, Context* c)</span> &#123;<br>    <span class="hljs-type">rt_thread_t</span> current;<br>    <span class="hljs-type">rt_ubase_t</span>* para;<br><br>    <span class="hljs-keyword">switch</span> (e.event) &#123;<br>        <span class="hljs-keyword">case</span> EVENT_YIELD:<br>            current = rt_thread_self();<br>            para = (<span class="hljs-type">rt_ubase_t</span>*)current-&gt;user_data;<br>            <span class="hljs-type">rt_ubase_t</span> to = para[<span class="hljs-number">0</span>];<br>            <span class="hljs-type">rt_ubase_t</span> from = para[<span class="hljs-number">1</span>];<br>            <span class="hljs-keyword">if</span> (from) &#123;<br>                *((Context**)from) = c;<br>            &#125;<br>            c = *(Context**)to;  <span class="hljs-comment">// 解引用，拿到一级指针</span><br>            <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">case</span> EVENT_IRQ_TIMER:<br>            <span class="hljs-keyword">return</span> c;<br>        <span class="hljs-keyword">default</span>:<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Unhandled event ID = %d\n&quot;</span>, e.event);<br>            assert(<span class="hljs-number">0</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> c;<br>&#125;<br></code></pre></td></tr></table></figure><p>swicth:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">void</span> <span class="hljs-title function_">rt_hw_context_switch_to</span><span class="hljs-params">(<span class="hljs-type">rt_ubase_t</span> to)</span> &#123;<br>    <span class="hljs-comment">// 利用 user_data PCB 成员 user_data 传参</span><br>    <span class="hljs-type">rt_ubase_t</span> temp_ud;  <span class="hljs-comment">// 当前栈上</span><br>    <span class="hljs-type">rt_ubase_t</span> user_data[<span class="hljs-number">2</span>];<br>    <span class="hljs-type">rt_thread_t</span> current = rt_thread_self();<br>    temp_ud = current-&gt;user_data;<br><br>    user_data[<span class="hljs-number">0</span>] = to;<br>    current-&gt;user_data = (<span class="hljs-type">rt_ubase_t</span>)user_data;<br>    yield();<br><br>    current-&gt;user_data = temp_ud;<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">rt_hw_context_switch</span><span class="hljs-params">(<span class="hljs-type">rt_ubase_t</span> from, <span class="hljs-type">rt_ubase_t</span> to)</span> &#123;<br>    <span class="hljs-type">rt_ubase_t</span> temp_ud;<br>    <span class="hljs-type">rt_ubase_t</span> user_data[<span class="hljs-number">2</span>];<br>    <span class="hljs-type">rt_thread_t</span> current = rt_thread_self();<br>    temp_ud = current-&gt;user_data;<br><br><br>    user_data[<span class="hljs-number">0</span>] = to;<br>    user_data[<span class="hljs-number">1</span>] = from;<br><br>    current-&gt;user_data = (<span class="hljs-type">rt_ubase_t</span>)user_data;<br><br>    yield();<br><br>    current-&gt;user_data = temp_ud;<br>&#125;<br></code></pre></td></tr></table></figure><p>这样就完美了，全局变量就不会飞了。当 swicth 获取到当前线程后：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-keyword">switch</span> (e.event) &#123;<br>        <span class="hljs-keyword">case</span> EVENT_YIELD:<br>            current = rt_thread_self();<br>            para = (<span class="hljs-type">rt_ubase_t</span>*)current-&gt;user_data;<br>            <span class="hljs-type">rt_ubase_t</span> to = para[<span class="hljs-number">0</span>];<br>            <span class="hljs-type">rt_ubase_t</span> from = para[<span class="hljs-number">1</span>];<br>            <span class="hljs-keyword">if</span> (from) &#123;<br>                *((Context**)from) = c;<br>            &#125;<br>            c = *(Context**)to;  <span class="hljs-comment">// 解引用，拿到一级指针</span><br>            <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">case</span> EVENT_IRQ_TIMER:<br>            <span class="hljs-keyword">return</span> c;<br>        <span class="hljs-keyword">default</span>:<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Unhandled event ID = %d\n&quot;</span>, e.event);<br>            assert(<span class="hljs-number">0</span>);<br>    &#125;<br></code></pre></td></tr></table></figure><p>便可以轻松愉快地处理了。</p><p>再跑一下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><code class="hljs bash">am-apps.data.size = d, am-apps.bss.size = d<br>heap: [0x80156000 - 0x88000000]<br><br> \ | /<br>- RT -     Thread Operating System<br> / | \     5.0.1 build Oct 21 2024 21:55:52<br> 2006 - 2022 Copyright by RT-Thread team<br>rt_hw_context_switch_to:to = 0x80148fd8<br>rt_hw_context_switch:to = 0x8215929c<br>[I/utest] utest is initialize success.<br>[I/utest] total utest testcase num: (0)<br>Hello RISC-V!<br>rt_hw_context_switch:to = 0x8215c07c<br>msh /&gt;<span class="hljs-built_in">help</span><br>RT-Thread shell commands:<br><span class="hljs-built_in">date</span>             - get <span class="hljs-built_in">date</span> and time or <span class="hljs-built_in">set</span> (<span class="hljs-built_in">local</span> timezone) [year month day hour min sec]<br>list             - list objects<br>version          - show RT-Thread version information<br>clear            - clear the terminal screen<br>free             - Show the memory usage <span class="hljs-keyword">in</span> the system.<br>ps               - List threads <span class="hljs-keyword">in</span> the system.<br><span class="hljs-built_in">help</span>             - RT-Thread shell <span class="hljs-built_in">help</span>.<br><span class="hljs-built_in">tail</span>             - <span class="hljs-built_in">print</span> the last N - lines data of the given file<br><span class="hljs-built_in">echo</span>             - <span class="hljs-built_in">echo</span> string to file<br><span class="hljs-built_in">df</span>               - disk free<br>umount           - Unmount the mountpoint<br>mount            - mount &lt;device&gt; &lt;mountpoint&gt; &lt;fstype&gt;<br>mkfs             - format disk with file system<br><span class="hljs-built_in">mkdir</span>            - Create the DIRECTORY.<br><span class="hljs-built_in">pwd</span>              - Print the name of the current working directory.<br><span class="hljs-built_in">cd</span>               - Change the shell working directory.<br><span class="hljs-built_in">rm</span>               - Remove(<span class="hljs-built_in">unlink</span>) the FILE(s).<br><span class="hljs-built_in">cat</span>              - Concatenate FILE(s)<br><span class="hljs-built_in">mv</span>               - Rename SOURCE to DEST.<br><span class="hljs-built_in">cp</span>               - Copy SOURCE to DEST.<br><span class="hljs-built_in">ls</span>               - List information about the FILEs.<br>utest_run        - utest_run [-thread or -<span class="hljs-built_in">help</span>] [testcase name] [loop num]<br>utest_list       - output all utest testcase<br>memtrace         - dump memory trace information<br>memcheck         - check memory data<br>am_fceux_am      - AM fceux_am<br>am_snake         - AM snake<br>am_typing_game   - AM typing_game<br>am_microbench    - AM microbench<br>am_hello         - AM hello<br><br>msh /&gt;<span class="hljs-built_in">date</span><br>[W/time] Cannot find a RTC device!<br><span class="hljs-built_in">local</span> time: Thu Jan  1 08:00:00 1970<br>timestamps: 0<br>timezone: UTC+8<br>msh /&gt;version<br><br> \ | /<br>- RT -     Thread Operating System<br> / | \     5.0.1 build Oct 21 2024 21:55:52<br> 2006 - 2022 Copyright by RT-Thread team<br>msh /&gt;free<br>total    : 132816792<br>used     : 33583304<br>maximum  : 33583304<br>available: 99233488<br>msh /&gt;ps<br>thread                   pri  status      sp     stack size max used left tick  error<br>------------------------ ---  ------- ---------- ----------  ------  ---------- ---<br>tshell                    20  running 0x000000a0 0x00001000    21%   0x0000000a OK<br>sys workq                 23  ready   0x000000a0 0x00002000    01%   0x0000000a OK<br>tidle0                    31  ready   0x000000a0 0x00004000    00%   0x00000020 OK<br>timer                      4  <span class="hljs-built_in">suspend</span> 0x00000120 0x00004000    03%   0x0000000a OK<br>main                      10  close   0x00000110 0x00000800    23%   0x00000014 OK<br>msh /&gt;<span class="hljs-built_in">pwd</span><br>/<br>msh /&gt;<span class="hljs-built_in">ls</span><br>No such directory<br>msh /&gt;memtrace<br><br>memory heap address:<br>name    : heap<br>total   : 0x132816792<br>used    : 0x33583304<br>max_used: 0x33583336<br>heap_ptr: 0x80156048<br>lfree   : 0x8215d110<br>heap_end: 0x87fffff0<br><br>--memory item information --<br>[0x80156048 -   32M] NONE<br>[0x82156058 -   12K] NONE<br>[0x82159260 -   176] NONE<br>[0x82159320 -    2K] NONE<br>[0x82159b30 -    16] main<br>[0x82159b50 -    72] main<br>[0x82159ba8 -   176] main<br>[0x82159c68 -    8K] main<br>[0x8215bc78 -   952] main<br>[0x8215c040 -   176] main<br>[0x8215c100 -    4K] main<br>[0x8215d110 -   94M]<br>msh /&gt;memcheck<br>msh /&gt;utest_list<br>[I/utest] Commands list :<br><br></code></pre></td></tr></table></figure><p>嗯，不错，说明实现正确。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;span id=&quot;more&quot;&gt;&lt;/span&gt;

&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;前面谈到了异常响应机制，如果在上下文恢复的时候，做点手脚，比如别让它回到原来的上下文，而是</summary>
      
    
    
    
    <category term="ysyx" scheme="http://blog.luliang.online/categories/ysyx/"/>
    
    <category term="nemu" scheme="http://blog.luliang.online/categories/ysyx/nemu/"/>
    
    
    <category term="ysyx" scheme="http://blog.luliang.online/tags/ysyx/"/>
    
    <category term="pa4.1" scheme="http://blog.luliang.online/tags/pa4-1/"/>
    
  </entry>
  
  <entry>
    <title>异常响应机制</title>
    <link href="http://blog.luliang.online/2024/10/18/%E5%BC%82%E5%B8%B8%E5%93%8D%E5%BA%94%E6%9C%BA%E5%88%B6/"/>
    <id>http://blog.luliang.online/2024/10/18/%E5%BC%82%E5%B8%B8%E5%93%8D%E5%BA%94%E6%9C%BA%E5%88%B6/</id>
    <published>2024-10-18T08:20:40.000Z</published>
    <updated>2025-02-18T13:55:24.289Z</updated>
    
    <content type="html"><![CDATA[<span id="more"></span><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在 riscv 中，当发生异常的时候，需要调用 ecall 指令来陷入异常:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-keyword">define</span> ECALL(dnpc)                                                       \</span><br><span class="hljs-meta">    &#123;                                                                     \</span><br><span class="hljs-meta">        bool success;                                                     \</span><br><span class="hljs-meta">        dnpc = (isa_raise_intr(isa_reg_str2val(<span class="hljs-string">&quot;$a7&quot;</span>, &amp;success), s-&gt;pc)); \</span><br><span class="hljs-meta">    &#125;</span><br><br><span class="hljs-type">word_t</span> <span class="hljs-title function_">isa_raise_intr</span><span class="hljs-params">(<span class="hljs-type">word_t</span> NO, <span class="hljs-type">vaddr_t</span> epc)</span> &#123;<br><br>    IFDEF(CONFIG_ETRACE, etrace(NO, epc));<br>    cpu.csr.mcause = NO;<br>    cpu.csr.mepc = epc+<span class="hljs-number">4</span>;<br>    <span class="hljs-keyword">return</span> cpu.csr.mtvec;<br>&#125;<br></code></pre></td></tr></table></figure><p>同时，ecall 会将当前的异常号保存到 mcause、将下一条指令的地址保存到 mepc(事实上，这个是否+4 取决于异常类型，后面会说到)以及设置异常处理入口，之后就进入到了异常处理阶段了。事实上，整个过程令人惊叹~</p><h2 id="一个例子"><a href="#一个例子" class="headerlink" title="一个例子"></a>一个例子</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;amtest.h&gt;</span></span><br><br><span class="hljs-type">void</span> (*entry)() = <span class="hljs-literal">NULL</span>; <span class="hljs-comment">// mp entry</span><br><br><span class="hljs-type">static</span> <span class="hljs-type">const</span> <span class="hljs-type">char</span> *tests[<span class="hljs-number">256</span>] = &#123;<br>  [<span class="hljs-string">&#x27;h&#x27;</span>] = <span class="hljs-string">&quot;hello&quot;</span>,<br>  [<span class="hljs-string">&#x27;H&#x27;</span>] = <span class="hljs-string">&quot;display this help message&quot;</span>,<br>  [<span class="hljs-string">&#x27;i&#x27;</span>] = <span class="hljs-string">&quot;interrupt/yield test&quot;</span>,<br>  [<span class="hljs-string">&#x27;d&#x27;</span>] = <span class="hljs-string">&quot;scan devices&quot;</span>,<br>  [<span class="hljs-string">&#x27;m&#x27;</span>] = <span class="hljs-string">&quot;multiprocessor test&quot;</span>,<br>  [<span class="hljs-string">&#x27;t&#x27;</span>] = <span class="hljs-string">&quot;real-time clock test&quot;</span>,<br>  [<span class="hljs-string">&#x27;k&#x27;</span>] = <span class="hljs-string">&quot;readkey test&quot;</span>,<br>  [<span class="hljs-string">&#x27;v&#x27;</span>] = <span class="hljs-string">&quot;display test&quot;</span>,<br>  [<span class="hljs-string">&#x27;a&#x27;</span>] = <span class="hljs-string">&quot;audio test&quot;</span>,<br>  [<span class="hljs-string">&#x27;p&#x27;</span>] = <span class="hljs-string">&quot;x86 virtual memory test&quot;</span>,<br>&#125;;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *args)</span> &#123;<br>  <span class="hljs-keyword">switch</span> (args[<span class="hljs-number">0</span>]) &#123;<br>    CASE(<span class="hljs-string">&#x27;h&#x27;</span>, hello);<br>    CASE(<span class="hljs-string">&#x27;i&#x27;</span>, hello_intr, IOE, CTE(simple_trap));<br>    CASE(<span class="hljs-string">&#x27;d&#x27;</span>, devscan, IOE);<br>    CASE(<span class="hljs-string">&#x27;m&#x27;</span>, mp_print, MPE);<br>    CASE(<span class="hljs-string">&#x27;t&#x27;</span>, rtc_test, IOE);<br>    CASE(<span class="hljs-string">&#x27;k&#x27;</span>, keyboard_test, IOE);<br>    CASE(<span class="hljs-string">&#x27;v&#x27;</span>, video_test, IOE);<br>    CASE(<span class="hljs-string">&#x27;a&#x27;</span>, audio_test, IOE);<br>    CASE(<span class="hljs-string">&#x27;p&#x27;</span>, vm_test, CTE(vm_handler), VME(simple_pgalloc, simple_pgfree));<br>    <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;H&#x27;</span>:<br>    <span class="hljs-keyword">default</span>:<br>      <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Usage: make run mainargs=*\n&quot;</span>);<br>      <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> ch = <span class="hljs-number">0</span>; ch &lt; <span class="hljs-number">256</span>; ch++) &#123;<br>        <span class="hljs-keyword">if</span> (tests[ch]) &#123;<br>          <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;  %c: %s\n&quot;</span>, ch, tests[ch]);<br>        &#125;<br>      &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>这个是主程序，我们需要关注这个程序的 i,也就是异常测试程序。它运行这个程序之前，它会 调用宏CTE(simple_trap)，这是在做：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-keyword">define</span> CTE(h) (&#123; Context *h(Event, Context *); cte_init(h); &#125;)</span><br></code></pre></td></tr></table></figure><p>事实上：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">static</span> Context* (*user_handler)(Event, Context*) = <span class="hljs-literal">NULL</span>;<br><br><span class="hljs-type">bool</span> <span class="hljs-title function_">cte_init</span><span class="hljs-params">(Context* (*handler)(Event, Context*))</span> &#123;<br>    <span class="hljs-comment">// initialize exception entry</span><br>    <span class="hljs-keyword">asm</span> <span class="hljs-title function_">volatile</span><span class="hljs-params">(<span class="hljs-string">&quot;csrw mtvec, %0&quot;</span> : : <span class="hljs-string">&quot;r&quot;</span>(__am_asm_trap))</span>;<br><br>    <span class="hljs-comment">// register event handler</span><br>    user_handler = handler;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里把回调函数user_handler 设置为用户传入 simple_trap 为处理函数。</p><p>可以看到，cte_init() 把__am_asm_trap 设为异常处理函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-keyword">define</span> concat_temp(x, y) x ## y</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> concat(x, y) concat_temp(x, y)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAP(c, f) c(f)</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">if</span> __riscv_xlen == 32</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> LOAD  lw</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> STORE sw</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> XLEN  4</span><br><span class="hljs-meta">#<span class="hljs-keyword">else</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> LOAD  ld</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> STORE sd</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> XLEN  8</span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> REGS_LO16(f) \</span><br><span class="hljs-meta">      f( 1)       f( 3) f( 4) f( 5) f( 6) f( 7) f( 8) f( 9) \</span><br><span class="hljs-meta">f(10) f(11) f(12) f(13) f(14) f(15)</span><br><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> __riscv_e</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> REGS_HI16(f) \</span><br><span class="hljs-meta">                                    f(16) f(17) f(18) f(19) \</span><br><span class="hljs-meta">f(20) f(21) f(22) f(23) f(24) f(25) f(26) f(27) f(28) f(29) \</span><br><span class="hljs-meta">f(30) f(31)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> NR_REGS 32</span><br><span class="hljs-meta">#<span class="hljs-keyword">else</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> REGS_HI16(f)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> NR_REGS 16</span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> REGS(f) REGS_LO16(f) REGS_HI16(f)</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> PUSH(n) STORE concat(x, n), (n * XLEN)(sp);</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> POP(n)  LOAD  concat(x, n), (n * XLEN)(sp);</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> CONTEXT_SIZE  ((NR_REGS + 3) * XLEN)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> OFFSET_SP     ( 2 * XLEN)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> OFFSET_CAUSE  ((NR_REGS + 0) * XLEN)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> OFFSET_STATUS ((NR_REGS + 1) * XLEN)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> OFFSET_EPC    ((NR_REGS + 2) * XLEN)</span><br><br>.align <span class="hljs-number">3</span><br>.globl __am_asm_trap<br>__am_asm_trap:<br>  addi sp, sp, -CONTEXT_SIZE<br><br>  <span class="hljs-title function_">MAP</span><span class="hljs-params">(REGS, PUSH)</span><br><br>  csrr t0, mcause<br>  csrr t1, mstatus<br>  csrr t2, mepc<br><br>  STORE t0, <span class="hljs-title function_">OFFSET_CAUSE</span><span class="hljs-params">(sp)</span><br>  STORE t1, <span class="hljs-title function_">OFFSET_STATUS</span><span class="hljs-params">(sp)</span><br>  STORE t2, <span class="hljs-title function_">OFFSET_EPC</span><span class="hljs-params">(sp)</span><br><br>  <span class="hljs-meta"># set mstatus.MPRV to pass difftest</span><br>  li a0, <span class="hljs-params">(<span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">17</span>)</span><br>  or t1, t1, a0<br>  csrw mstatus, t1<br><br>  mv a0, sp<br>  jal __am_irq_handle<br><br>  LOAD t1, <span class="hljs-title function_">OFFSET_STATUS</span><span class="hljs-params">(sp)</span><br>  LOAD t2, <span class="hljs-title function_">OFFSET_EPC</span><span class="hljs-params">(sp)</span><br>  csrw mstatus, t1<br>  csrw mepc, t2<br><br>  <span class="hljs-title function_">MAP</span><span class="hljs-params">(REGS, POP)</span><br><br>  addi sp, sp, CONTEXT_SIZE<br>  mret<br><br></code></pre></td></tr></table></figure><p>这个程序做了几件事：</p><ul><li>为 context 开辟空间；</li><li>将 通用寄存器保存到栈上；</li><li>将 csr 寄存器保存到栈上；</li><li>跳转到异常处理函数；</li><li>处理完后返回；</li><li>恢复 status 到 mstatus；</li><li>恢复 dnpc 到 mepc</li><li>恢复 sp</li><li>处理完成，返回（接着执行 dnpc）</li></ul><p>我们看看__am_irq_handle():</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs C">Context* __am_irq_handle(Context* c) &#123;<br>    <span class="hljs-keyword">if</span> (user_handler) &#123;<br>        Event ev = &#123;<span class="hljs-number">0</span>&#125;;<br>        <span class="hljs-keyword">switch</span> (c-&gt;mcause) &#123;<br>            <span class="hljs-keyword">case</span> <span class="hljs-number">-1</span>:<br>                ev.event = EVENT_YIELD;<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">default</span>:<br>                ev.event = EVENT_ERROR;<br>                <span class="hljs-keyword">break</span>;<br>        &#125;<br><br>        c = user_handler(ev, c);<br>        assert(c != <span class="hljs-literal">NULL</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> c;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>这一节可谓是惊为天人，它把 sp 栈上的数据排布的完全和 context 一样，然后通过指针转型获取传入的 context。</p><p>然后就是根据 a7 的异常号，再次确定事件编号。然后根据事件编号，传入到回调函数 user_handler()，就可以处理了。处理好了后，返回到 trap.S，然后返回，整个过程就结束了。</p><p>我们来看看用户程序：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;amtest.h&gt;</span></span><br><br>Context* <span class="hljs-title function_">simple_trap</span><span class="hljs-params">(Event ev, Context* ctx)</span> &#123;<br>    <span class="hljs-keyword">switch</span> (ev.event) &#123;<br>        <span class="hljs-keyword">case</span> EVENT_IRQ_TIMER:<br>            putch(<span class="hljs-string">&#x27;t&#x27;</span>);<br>            <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">case</span> EVENT_IRQ_IODEV:<br>            putch(<span class="hljs-string">&#x27;d&#x27;</span>);<br>            <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">case</span> EVENT_YIELD:<br>            putch(<span class="hljs-string">&#x27;y&#x27;</span>);<br>            <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">default</span>:<br>            panic(<span class="hljs-string">&quot;Unhandled event&quot;</span>);<br>            <span class="hljs-keyword">break</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> ctx;<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">hello_intr</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Hello, AM World @ &quot;</span> __ISA__ <span class="hljs-string">&quot;\n&quot;</span>);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;  t = timer, d = device, y = yield\n&quot;</span>);<br>    io_read(AM_INPUT_CONFIG);<br>    iset(<span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">volatile</span> <span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10000000</span>; i++)<br>            ;<br>        yield();<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>这个是一个main 的 子程序，它实现了trap 处理函数 simple_trap，这个函数会根据应用程序执行不同的陷入来执行不同的操作，比如输出 t、d、y 等。</p><p>hello_intr() 就很简单了，首先它会 io_read、iset(1)，事实上没做什么，这里不用考虑。接着为了防止 yield()太快，它加入了一段空循环，然后死循环。</p><p>yield()做了两件事:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">void</span> <span class="hljs-title function_">yield</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> __riscv_e</span><br>    <span class="hljs-keyword">asm</span> <span class="hljs-title function_">volatile</span><span class="hljs-params">(<span class="hljs-string">&quot;li a5, -1; ecall&quot;</span>)</span>;<br><span class="hljs-meta">#<span class="hljs-keyword">else</span></span><br>    <span class="hljs-keyword">asm</span> <span class="hljs-title function_">volatile</span><span class="hljs-params">(<span class="hljs-string">&quot;li a7, -1; ecall&quot;</span>)</span>;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>&#125;<br></code></pre></td></tr></table></figure><p>它将 -1 加载到 a7 寄存器，然后 ecall，这里是的 ecall 实现如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-keyword">define</span> ECALL(dnpc)                                                       \</span><br><span class="hljs-meta">    &#123;                                                                     \</span><br><span class="hljs-meta">        bool success;                                                     \</span><br><span class="hljs-meta">        dnpc = (isa_raise_intr(isa_reg_str2val(<span class="hljs-string">&quot;$a7&quot;</span>, &amp;success), s-&gt;pc)); \</span><br><span class="hljs-meta">    &#125;</span><br></code></pre></td></tr></table></figure><p>在执行 ecall 的时候，得做两件事：</p><ul><li>取回 a7 中的异常号；</li><li>处理进入异常处理之前的事情。</li></ul><p>也就是 前面说到的：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">word_t</span> <span class="hljs-title function_">isa_raise_intr</span><span class="hljs-params">(<span class="hljs-type">word_t</span> NO, <span class="hljs-type">vaddr_t</span> epc)</span> &#123;<br><br>    IFDEF(CONFIG_ETRACE, etrace(NO, epc));<br>    cpu.csr.mcause = NO;<br>    cpu.csr.mepc = epc+<span class="hljs-number">4</span>;<br>    <span class="hljs-keyword">return</span> cpu.csr.mtvec;<br>&#125;<br></code></pre></td></tr></table></figure><p>之后，就进入了__am_asm_trap，然后保存现场、传入context 给处理函数处理，确定事件类型，然后传给用户程序处理。然后返回到 trap.S，然后恢复现场，返回 mret:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-keyword">define</span> MRET(dnpc)                                                       \</span><br><span class="hljs-meta">    &#123;                                                                    \</span><br><span class="hljs-meta">        dnpc = cpu.csr.mepc;                                             \</span><br><span class="hljs-meta">    &#125;</span><br></code></pre></td></tr></table></figure><p>整个过程很有意思，处处体现了解耦的思想：</p><ul><li>用户想要进行特殊的中断处理，必须提供 handler;</li><li>中断向量调用的程序，会调用一个专门的函数，这个函数会根据事件类型再次调用用户的 handler，让它自己处理。</li></ul><p>整个过程如下：</p><p><img src="https://raw.githubusercontent.com/Luyoung0001/picBed/main/20241018.png"></p><h2 id="后话"><a href="#后话" class="headerlink" title="后话"></a>后话</h2><p>为什么dnpc要+4?</p><p>答案很简单，如果不加 4，那么它就不断得重复 ecall，因此它的 ftrace 就像这样：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs bash">0x8000152c:     call [ __am_irq_handle@0x800013c8<br>0x80001420:      call [ simple_trap@0x80000ed8<br>0x80000f64:       call [ putch@0x8000101c<br>y0x80001024:      ret [ simple_trap@0x80000ed8<br>0x80000f78:     ret [ __am_irq_handle@0x800013c8<br>0x8000152c:     call [ __am_irq_handle@0x800013c8<br>0x80001420:      call [ simple_trap@0x80000ed8<br>0x80000f64:       call [ putch@0x8000101c<br>y0x80001024:      ret [ simple_trap@0x80000ed8<br>0x80000f78:     ret [ __am_irq_handle@0x800013c8<br>0x8000152c:     call [ __am_irq_handle@0x800013c8<br>0x80001420:      call [ simple_trap@0x80000ed8<br>0x80000f64:       call [ putch@0x8000101c<br>y0x80001024:      ret [ simple_trap@0x80000ed8<br>0x80000f78:     ret [ __am_irq_handle@0x800013c8<br>0x8000152c:     call [ __am_irq_handle@0x800013c8<br>0x80001420:      call [ simple_trap@0x80000ed8<br>0x80000f64:       call [ putch@0x8000101c<br>y0x80001024:      ret [ simple_trap@0x80000ed8<br>0x80000f78:     ret [ __am_irq_handle@0x800013c8<br>0x8000152c:     call [ __am_irq_handle@0x800013c8<br>0x80001420:      call [ simple_trap@0x80000ed8<br></code></pre></td></tr></table></figure><p>如果+4 那么它在处理完异常之后，就干别的事了：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs bash">0x80001014:    call [ yield@0x80001478<br>0x8000152c:     call [ __am_irq_handle@0x800013c8<br>0x80001420:      call [ simple_trap@0x80000ed8<br>0x80000f64:       call [ putch@0x8000101c<br>y0x80001024:      ret [ simple_trap@0x80000ed8<br>0x80000f78:     ret [ __am_irq_handle@0x800013c8<br>0x80001480:   ret [ hello_intr@0x80000fb4<br>0x80001014:    call [ yield@0x80001478<br>0x8000152c:     call [ __am_irq_handle@0x800013c8<br>0x80001420:      call [ simple_trap@0x80000ed8<br>0x80000f64:       call [ putch@0x8000101c<br>y0x80001024:      ret [ simple_trap@0x80000ed8<br>0x80000f78:     ret [ __am_irq_handle@0x800013c8<br>0x80001480:   ret [ hello_intr@0x80000fb4<br>0x80001014:    call [ yield@0x80001478<br>0x8000152c:     call [ __am_irq_handle@0x800013c8<br>0x80001420:      call [ simple_trap@0x80000ed8<br>0x80000f64:       call [ putch@0x8000101c<br>y0x80001024:      ret [ simple_trap@0x80000ed8<br>0x80000f78:     ret [ __am_irq_handle@0x800013c8<br></code></pre></td></tr></table></figure><p>可以看到，他们的过程完全不同。虽然都是打印字符 ‘y’。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;span id=&quot;more&quot;&gt;&lt;/span&gt;

&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;在 riscv 中，当发生异常的时候，需要调用 ecall 指令来陷入异常:&lt;/p&gt;
&lt;f</summary>
      
    
    
    
    <category term="ysyx" scheme="http://blog.luliang.online/categories/ysyx/"/>
    
    <category term="nemu" scheme="http://blog.luliang.online/categories/ysyx/nemu/"/>
    
    
    <category term="ysyx" scheme="http://blog.luliang.online/tags/ysyx/"/>
    
    <category term="pa3" scheme="http://blog.luliang.online/tags/pa3/"/>
    
    <category term="异常处理" scheme="http://blog.luliang.online/tags/%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>npc 中三种设备的区别</title>
    <link href="http://blog.luliang.online/2024/10/16/npc%20%E4%B8%AD%E4%B8%89%E7%A7%8D%E8%AE%BE%E5%A4%87%E7%9A%84%E5%B7%AE%E5%88%AB/"/>
    <id>http://blog.luliang.online/2024/10/16/npc%20%E4%B8%AD%E4%B8%89%E7%A7%8D%E8%AE%BE%E5%A4%87%E7%9A%84%E5%B7%AE%E5%88%AB/</id>
    <published>2024-10-16T08:20:40.000Z</published>
    <updated>2025-02-18T13:55:24.283Z</updated>
    
    <content type="html"><![CDATA[<span id="more"></span><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在把 PA2.3 做完之后，顺手把 ysyx 的 npc 中的设备模仿 nemu 也实现了一下，分别是串口、时钟、vga，本文讨论一下这三种设备的区别。事实上，这三种设备循序渐进，虽然是三种设备，但其实在 CPU 眼里，它就是同一种东西，都是读写内存。</p><h2 id="设备"><a href="#设备" class="headerlink" title="设备"></a>设备</h2><p>在 nemu 的模型中，程序访问设备的时候，会提供统一的接口，比如 io_read、io_write，比如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;amtest.h&gt;</span></span><br><br><span class="hljs-type">void</span> <span class="hljs-title function_">rtc_test</span><span class="hljs-params">()</span> &#123;<br>    AM_TIMER_RTC_T rtc;<br>    <span class="hljs-type">int</span> sec = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>) &#123;<br>        <span class="hljs-keyword">while</span> (io_read(AM_TIMER_UPTIME).us / <span class="hljs-number">1000000</span> &lt; sec)<br>            ;<br>        rtc = io_read(AM_TIMER_RTC);<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d-%d-%d %02d:%02d:%02d GMT (&quot;</span>, rtc.year, rtc.month, rtc.day,<br>               rtc.hour, rtc.minute, rtc.second);<br>        <span class="hljs-keyword">if</span> (sec == <span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d second).\n&quot;</span>, sec);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d seconds).\n&quot;</span>, sec);<br>        &#125;<br>        sec++;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里读取了 AM_TIMER_UPTIME、AM_TIMER_RTC 中的元素，这是抽象寄存器。io_read 是运行时环境提供的接口，事实上，它封装了 ioe:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-keyword">define</span> io_read(reg) \</span><br><span class="hljs-meta">  (&#123; reg##_T __io_param; \</span><br><span class="hljs-meta">    ioe_read(reg, &amp;__io_param); \</span><br><span class="hljs-meta">    __io_param; &#125;)</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> io_write(reg, ...) \</span><br><span class="hljs-meta">  (&#123; reg##_T __io_param = (reg##_T) &#123; __VA_ARGS__ &#125;; \</span><br><span class="hljs-meta">    ioe_write(reg, &amp;__io_param); &#125;)</span><br></code></pre></td></tr></table></figure><p>ioe 是一种扩展的 io，它提供了一组架构无关性的 API：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">bool</span> <span class="hljs-title function_">ioe_init</span><span class="hljs-params">()</span>;<br><span class="hljs-type">void</span> <span class="hljs-title function_">ioe_read</span><span class="hljs-params">(<span class="hljs-type">int</span> reg, <span class="hljs-type">void</span> *buf)</span>;<br><span class="hljs-type">void</span> <span class="hljs-title function_">ioe_write</span><span class="hljs-params">(<span class="hljs-type">int</span> reg, <span class="hljs-type">void</span> *buf)</span>;<br></code></pre></td></tr></table></figure><p>第一个 API 用于进行 IOE 相关的初始化操作。后两个 API 分别用于从编号为 reg 的寄存器中读出内容到缓冲区 buf 中， 以及往编号为reg寄存器中写入缓冲区buf中的内容。 在IOE中， 我们希望采用一种架构无关的”抽象寄存器”， 这个reg其实是一个功能编号。 我们约定在不同的架构中，同一个功能编号的含义也是相同的， 这样就实现了设备寄存器的抽象。</p><p>ioe_read() 和ioe_write() 都是通过抽象寄存器的编号索引到一个处理函数, 然后调用它. 处理函数的具体功能和寄存器编号相关。</p><h2 id="串口"><a href="#串口" class="headerlink" title="串口"></a>串口</h2><p>串口怎么实现？我觉得还是注册一个地址，然后往这个地址中写入数据就行了。事实上，nemu 的串口就是这样实现的：</p><p>比如，我们要实现 putch 功能，我们的愿望是一旦应用程序调用了 putch，比如 putch(‘A’)，那么运行时环境就会打印出来一个 ‘A’。</p><p>串口是一种设备，putch 会将’A’写在某个地址上，而 nemu 中有一种底层的机制：访问内存的 handler 检测到这个写入地址是设备而不是内存之后，就会调用一个函数，让它去处理，比如显示这个字符。简单吧</p><p>运行时环境的接口：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title function_">outb</span><span class="hljs-params">(<span class="hljs-type">uintptr_t</span> addr, <span class="hljs-type">uint8_t</span>  data)</span> &#123; *(<span class="hljs-keyword">volatile</span> <span class="hljs-type">uint8_t</span>  *)addr = data; &#125;<br><span class="hljs-meta">#<span class="hljs-keyword">define</span> DEVICE_BASE 0xa0000000</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MMIO_BASE   0xa0000000</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> SERIAL_PORT     (DEVICE_BASE + 0x00003f8)</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">putch</span><span class="hljs-params">(<span class="hljs-type">char</span> ch)</span> &#123;<br>  outb(SERIAL_PORT, ch);<br>&#125;<br><br></code></pre></td></tr></table></figure><p>这里的核心就是 outb 的实现，它是一个访存操作，而且访问的地址是一个特殊的地址。这个访存操作会被编译器编译成sbu 指令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs asm">80000088 &lt;putch&gt;:<br>80000088:a00007b7          luia5,0xa0000<br>8000008c:3ea78c23          sba0,1016(a5) # a00003f8 &lt;_end+0x1fff73f8&gt;<br>80000090:00008067          ret<br></code></pre></td></tr></table></figure><p>之后呢？那当然是把二进制文件丢到 CPU 上执行了，当 cpu 执行到：<code>sba0,1016(a5)</code>的时候，这时候访存模块就被激活了：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-keyword">extern</span> <span class="hljs-string">&quot;C&quot;</span> <span class="hljs-type">void</span> <span class="hljs-title function_">memo_access_write</span><span class="hljs-params">(<span class="hljs-type">int</span> waddr, <span class="hljs-type">int</span> wdata, <span class="hljs-type">char</span> wmask)</span> &#123;<br>    <span class="hljs-comment">// 总是往地址为`waddr &amp; ~0x3u`的4字节按写掩码`wmask`写入`wdata`</span><br>    <span class="hljs-comment">// `wmask`中每比特表示`wdata`中1个字节的掩码,</span><br>    <span class="hljs-comment">// 如`wmask = 0x3`代表只写入最低2个字节, 内存中的其它字节保持不变</span><br><br>    <span class="hljs-keyword">switch</span> (wmask) &#123;<br>        <span class="hljs-keyword">case</span> <span class="hljs-number">0x1</span>:<br>            paddr_write(waddr, <span class="hljs-number">1</span>, wdata);<br>            <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">case</span> <span class="hljs-number">0x3</span>:<br>            paddr_write(waddr, <span class="hljs-number">2</span>, wdata);<br>            <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">case</span> <span class="hljs-number">0xf</span>:<br>            paddr_write(waddr, <span class="hljs-number">4</span>, wdata);<br>            <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">default</span>:<br>            paddr_write(waddr, <span class="hljs-number">4</span>, wdata);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这是 verilog 中的 DPI-C 函数，它会调用 <code>paddr_write(waddr, 1, wdata)</code>，之后进入：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">void</span> <span class="hljs-title function_">paddr_write</span><span class="hljs-params">(<span class="hljs-type">paddr_t</span> addr, <span class="hljs-type">int</span> len, <span class="hljs-type">word_t</span> data)</span> &#123;<br>    IFDEF(CONFIG_MTRACE, display_memory_write(addr, len, data));<br>    <span class="hljs-keyword">if</span> (likely(in_pmem(addr))) &#123;<br>        pmem_write(addr, len, data);<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    IFDEF(CONFIG_DEVICE, mmio_write(addr, len, data); <span class="hljs-keyword">return</span> );<br>    out_of_bound(addr);<br>&#125;<br></code></pre></td></tr></table></figure><p>这时候，就会检查地址，如果不是访存，那么就会进行到<code>IFDEF(CONFIG_DEVICE, mmio_write(addr, len, data); return )</code>:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">void</span> <span class="hljs-title function_">mmio_write</span><span class="hljs-params">(<span class="hljs-type">paddr_t</span> addr, <span class="hljs-type">int</span> len, <span class="hljs-type">word_t</span> data)</span> &#123;<br>    map_write(addr, len, data, fetch_mmio_map(addr));<br>&#125;<br></code></pre></td></tr></table></figure><p>这个函数会根据地址，获取相应的注册了的 mmio_map，mmio_map 是系统启动的时候注册的内存映射：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">void</span> <span class="hljs-title function_">init_serial</span><span class="hljs-params">()</span> &#123;<br>  serial_base = new_space(<span class="hljs-number">8</span>);<br>  add_mmio_map(<span class="hljs-string">&quot;serial&quot;</span>, CONFIG_SERIAL_MMIO, serial_base, <span class="hljs-number">8</span>, serial_io_handler);<br>&#125;<br></code></pre></td></tr></table></figure><p>拿到 mmip_map 之后，就会进入：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">void</span> <span class="hljs-title function_">map_write</span><span class="hljs-params">(<span class="hljs-type">paddr_t</span> addr, <span class="hljs-type">int</span> len, <span class="hljs-type">word_t</span> data, IOMap* <span class="hljs-built_in">map</span>)</span> &#123;<br>    assert(len &gt;= <span class="hljs-number">1</span> &amp;&amp; len &lt;= <span class="hljs-number">8</span>);<br>    check_bound(<span class="hljs-built_in">map</span>, addr);<br>    <span class="hljs-type">paddr_t</span> offset = addr - <span class="hljs-built_in">map</span>-&gt;low;<br>    host_write(<span class="hljs-built_in">map</span>-&gt;space + offset, len, data);<br>    invoke_callback(<span class="hljs-built_in">map</span>-&gt;callback, offset, len, <span class="hljs-literal">true</span>);<br>    IFDEF(CONFIG_DTRACE, trace_dwrite(addr, len, data, <span class="hljs-built_in">map</span>););<br>&#125;<br></code></pre></td></tr></table></figure><p>分别做一些检查，然后计算 offset，然后准确地将这个数据写入到目标地址（准备数据）。然后激活回调函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">serial_putc</span><span class="hljs-params">(<span class="hljs-type">char</span> ch)</span> &#123;<br>  MUXDEF(CONFIG_TARGET_AM, putch(ch), putc(ch, <span class="hljs-built_in">stderr</span>));<br>&#125;<br><br><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">serial_io_handler</span><span class="hljs-params">(<span class="hljs-type">uint32_t</span> offset, <span class="hljs-type">int</span> len, <span class="hljs-type">bool</span> is_write)</span> &#123;<br>  assert(len == <span class="hljs-number">1</span>);<br>  <span class="hljs-keyword">switch</span> (offset) &#123;<br>    <span class="hljs-keyword">case</span> CH_OFFSET:<br>      <span class="hljs-keyword">if</span> (is_write) serial_putc(serial_base[<span class="hljs-number">0</span>]);<br>      <span class="hljs-keyword">else</span> <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;do not support read&quot;</span>);<br>      <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">default</span>: <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;do not support offset = %d&quot;</span>, offset);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到，回调函数其实是在实现功能。</p><p>以上就是串口的整个过程。</p><h2 id="时钟"><a href="#时钟" class="headerlink" title="时钟"></a>时钟</h2><p>事实上，时钟和串口很接近，但是也有一些不同。</p><p>首先是注册 mmio_map：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">rtc_io_handler</span><span class="hljs-params">(<span class="hljs-type">uint32_t</span> offset, <span class="hljs-type">int</span> len, <span class="hljs-type">bool</span> is_write)</span> &#123;<br>    assert(offset == <span class="hljs-number">0</span> || offset == <span class="hljs-number">4</span>);<br>    <span class="hljs-keyword">if</span> (!is_write &amp;&amp; offset == <span class="hljs-number">4</span>) &#123; <span class="hljs-comment">// 确保每一次读取时间(64位)，只更新一次寄存器</span><br>        <span class="hljs-type">uint64_t</span> us = get_time();<br>        rtc_port_base[<span class="hljs-number">0</span>] = (<span class="hljs-type">uint32_t</span>)us;<br>        rtc_port_base[<span class="hljs-number">1</span>] = us &gt;&gt; <span class="hljs-number">32</span>;<br>    &#125;<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">init_timer</span><span class="hljs-params">()</span> &#123;<br>    rtc_port_base = (<span class="hljs-type">uint32_t</span>*)new_space(<span class="hljs-number">8</span>);<br>    add_mmio_map(<span class="hljs-string">&quot;rtc&quot;</span>, CONFIG_RTC_MMIO, rtc_port_base, <span class="hljs-number">8</span>, rtc_io_handler);<br>&#125;<br></code></pre></td></tr></table></figure><p>这里的回调函数是在将时间放到两个字，也就是准备数据。</p><p>当应用程序调用时间接口：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;amtest.h&gt;</span></span><br><br><span class="hljs-type">void</span> <span class="hljs-title function_">rtc_test</span><span class="hljs-params">()</span> &#123;<br>    AM_TIMER_RTC_T rtc;<br>    <span class="hljs-type">int</span> sec = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>) &#123;<br>        <span class="hljs-keyword">while</span> (io_read(AM_TIMER_UPTIME).us / <span class="hljs-number">1000000</span> &lt; sec)<br>            ;<br>        rtc = io_read(AM_TIMER_RTC);<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d-%d-%d %02d:%02d:%02d GMT (&quot;</span>, rtc.year, rtc.month, rtc.day,<br>               rtc.hour, rtc.minute, rtc.second);<br>        <span class="hljs-keyword">if</span> (sec == <span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d second).\n&quot;</span>, sec);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d seconds).\n&quot;</span>, sec);<br>        &#125;<br>        sec++;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>实际上，在调用这个接口：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-type">uint32_t</span> <span class="hljs-title function_">inl</span><span class="hljs-params">(<span class="hljs-type">uintptr_t</span> addr)</span> &#123;<br>    <span class="hljs-keyword">return</span> *(<span class="hljs-keyword">volatile</span> <span class="hljs-type">uint32_t</span>*)addr;<br>&#125;<br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> DEVICE_BASE 0xa0000000</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> RTC_ADDR (DEVICE_BASE + 0x0000048)</span><br><span class="hljs-type">void</span> __am_timer_uptime(AM_TIMER_UPTIME_T* uptime) &#123;<br>    <span class="hljs-type">uint32_t</span> high = inl(RTC_ADDR + <span class="hljs-number">4</span>);<br>    <span class="hljs-type">uint32_t</span> low = inl(RTC_ADDR);<br>    uptime-&gt;us = (<span class="hljs-type">uint64_t</span>)low + (((<span class="hljs-type">uint64_t</span>)high) &lt;&lt; <span class="hljs-number">32</span>);<br>&#125;<br><br><span class="hljs-type">void</span> __am_timer_rtc(AM_TIMER_RTC_T* rtc) &#123;<br>    rtc-&gt;second = <span class="hljs-number">0</span>;<br>    rtc-&gt;minute = <span class="hljs-number">0</span>;<br>    rtc-&gt;hour = <span class="hljs-number">0</span>;<br>    rtc-&gt;day = <span class="hljs-number">0</span>;<br>    rtc-&gt;month = <span class="hljs-number">0</span>;<br>    rtc-&gt;year = <span class="hljs-number">1900</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到，它和串口几乎一样，都是在读取数据。这个读取会被翻译成汇编指令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs asm">800013b4 &lt;__am_timer_uptime&gt;:<br>800013b4:a00007b7          luia5,0xa0000<br>800013b8:04c7a703          lwa4,76(a5) # a000004c &lt;_end+0x1ff6304c&gt;<br>800013bc:0487a783          lwa5,72(a5)<br>800013c0:00e52223          swa4,4(a0)<br>800013c4:00f52023          swa5,0(a0)<br>800013c8:00008067          ret<br></code></pre></td></tr></table></figure><p>之后，会被CPU执行，然后读取：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">word_t</span> <span class="hljs-title function_">mmio_read</span><span class="hljs-params">(<span class="hljs-type">paddr_t</span> addr, <span class="hljs-type">int</span> len)</span> &#123;<br>    <span class="hljs-keyword">return</span> map_read(addr, len, fetch_mmio_map(addr));<br>&#125;<br></code></pre></td></tr></table></figure><p>同样，这里也会根据地址获取 mmio_map，之后就进入了 map_read:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">word_t</span> <span class="hljs-title function_">map_read</span><span class="hljs-params">(<span class="hljs-type">paddr_t</span> addr, <span class="hljs-type">int</span> len, IOMap* <span class="hljs-built_in">map</span>)</span> &#123;<br>    assert(len &gt;= <span class="hljs-number">1</span> &amp;&amp; len &lt;= <span class="hljs-number">8</span>);<br>    check_bound(<span class="hljs-built_in">map</span>, addr);<br>    <span class="hljs-type">paddr_t</span> offset = addr - <span class="hljs-built_in">map</span>-&gt;low;<br>    invoke_callback(<span class="hljs-built_in">map</span>-&gt;callback, offset, len, <span class="hljs-literal">false</span>);  <span class="hljs-comment">// prepare data to read</span><br>    <span class="hljs-type">word_t</span> ret = host_read(<span class="hljs-built_in">map</span>-&gt;space + offset, len);<br>    IFDEF(CONFIG_DTRACE, trace_dread(addr, len, <span class="hljs-built_in">map</span>));<br>    <span class="hljs-keyword">return</span> ret;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>同样就是安全检查，然后这里首先是激活回调函数：因为读取之前，首先得准备数据：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">rtc_io_handler</span><span class="hljs-params">(<span class="hljs-type">uint32_t</span> offset, <span class="hljs-type">int</span> len, <span class="hljs-type">bool</span> is_write)</span> &#123;<br>    assert(offset == <span class="hljs-number">0</span> || offset == <span class="hljs-number">4</span>);<br>    <span class="hljs-keyword">if</span> (!is_write &amp;&amp; offset == <span class="hljs-number">4</span>) &#123; <span class="hljs-comment">// 确保每一次读取时间(64位)，只更新一次寄存器</span><br>        <span class="hljs-type">uint64_t</span> us = get_time();<br>        rtc_port_base[<span class="hljs-number">0</span>] = (<span class="hljs-type">uint32_t</span>)us;<br>        rtc_port_base[<span class="hljs-number">1</span>] = us &gt;&gt; <span class="hljs-number">32</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这路需要注意的是，只有当 offset &#x3D;&#x3D; 4的时候，才会更新寄存器。也就是当：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">void</span> __am_timer_uptime(AM_TIMER_UPTIME_T* uptime) &#123;<br>    <span class="hljs-type">uint32_t</span> high = inl(RTC_ADDR + <span class="hljs-number">4</span>);<br>    <span class="hljs-type">uint32_t</span> low = inl(RTC_ADDR);<br>    uptime-&gt;us = (<span class="hljs-type">uint64_t</span>)low + (((<span class="hljs-type">uint64_t</span>)high) &lt;&lt; <span class="hljs-number">32</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>第一次获取 high 的时候 更新，获取 low 的时候，不会更新时间寄存器。</p><p>当时间准备好后，就可以读取以及返回了：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">word_t</span> ret = host_read(<span class="hljs-built_in">map</span>-&gt;space + offset, len);<br></code></pre></td></tr></table></figure><p>这样就完成了时钟。</p><h2 id="VGA"><a href="#VGA" class="headerlink" title="VGA"></a>VGA</h2><p>VGA 前两个设备很不一样，因为它没有回调函数。这是为什么呢？</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs C">...<br><br><span class="hljs-type">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title function_">update_screen</span><span class="hljs-params">()</span> &#123;<br>    SDL_UpdateTexture(texture, <span class="hljs-literal">NULL</span>, vmem, SCREEN_W * <span class="hljs-keyword">sizeof</span>(<span class="hljs-type">uint32_t</span>));<br>    SDL_RenderClear(renderer);<br>    SDL_RenderCopy(renderer, texture, <span class="hljs-literal">NULL</span>, <span class="hljs-literal">NULL</span>);<br>    SDL_RenderPresent(renderer);<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">vga_update_screen</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">uint32_t</span> sync = vgactl_port_base[<span class="hljs-number">1</span>];<br>    <span class="hljs-keyword">if</span> (sync) &#123;<br>        update_screen();<br>        vgactl_port_base[<span class="hljs-number">1</span>] = <span class="hljs-number">0</span>;<br>    &#125;<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">init_vga</span><span class="hljs-params">()</span> &#123;<br>    vgactl_port_base = (<span class="hljs-type">uint32_t</span>*)new_space(<span class="hljs-number">8</span>);<br>    vgactl_port_base[<span class="hljs-number">0</span>] = (screen_width() &lt;&lt; <span class="hljs-number">16</span>) | screen_height();<br><br>    add_mmio_map(<span class="hljs-string">&quot;vgactl&quot;</span>, CONFIG_VGA_CTL_MMIO, vgactl_port_base, <span class="hljs-number">8</span>, <span class="hljs-literal">NULL</span>);<br><br>    vmem = new_space(screen_size());<br>    add_mmio_map(<span class="hljs-string">&quot;vmem&quot;</span>, CONFIG_FB_ADDR, vmem, screen_size(), <span class="hljs-literal">NULL</span>);<br>    IFDEF(CONFIG_VGA_SHOW_SCREEN, init_screen());<br>    IFDEF(CONFIG_VGA_SHOW_SCREEN, <span class="hljs-built_in">memset</span>(vmem, <span class="hljs-number">0</span>, screen_size()));<br>&#125;<br></code></pre></td></tr></table></figure><p>因为，视频显示并不是说需要一个特定的事件（比如读写某些特定地址）去触发，而是需要每时每刻都将画面更新一下。那我们应该选用什么样子的事件呢？没错就是 CPU 每执行一个指令，我们就刷新：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-comment">// 执行一步</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">stepi</span><span class="hljs-params">()</span> &#123;<br>    step();<br>    IFDEF(CONFIG_DIFFTEST,<br>          difftest_step(top-&gt;rootp-&gt;Top__DOT__core__DOT__pc_reg, <span class="hljs-number">0</span>));<br>    IFDEF(CONFIG_DEVICE, device_update());<br>&#125;<br></code></pre></td></tr></table></figure><p>device_update():</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">void</span> <span class="hljs-title function_">device_update</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">static</span> <span class="hljs-type">uint64_t</span> last = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">uint64_t</span> now = get_time();<br>    <span class="hljs-keyword">if</span> (now - last &lt; <span class="hljs-number">1000000</span> / TIMER_HZ) &#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    last = now;<br><br>    IFDEF(CONFIG_HAS_VGA, vga_update_screen());<br><br><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> CONFIG_TARGET_AM</span><br>    SDL_Event event;<br>    <span class="hljs-keyword">while</span> (SDL_PollEvent(&amp;event)) &#123;<br>        <span class="hljs-keyword">switch</span> (event.type) &#123;<br>            <span class="hljs-keyword">case</span> SDL_QUIT:<br>                npc_state.state = NPC_QUIT;<br>                <span class="hljs-keyword">break</span>;<br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> CONFIG_HAS_KEYBOARD</span><br>            <span class="hljs-comment">// If a key was pressed</span><br>            <span class="hljs-keyword">case</span> SDL_KEYDOWN:<br>            <span class="hljs-keyword">case</span> SDL_KEYUP: &#123;<br>                <span class="hljs-type">uint8_t</span> k = event.key.keysym.scancode;<br>                <span class="hljs-type">bool</span> is_keydown = (event.key.type == SDL_KEYDOWN);<br>                send_key(k, is_keydown);<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>            <span class="hljs-keyword">default</span>:<br>                <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>&#125;<br></code></pre></td></tr></table></figure><p>至于访问设备，也就是写（没错，只有写）：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">void</span> __am_gpu_fbdraw(AM_GPU_FBDRAW_T* ctl) &#123;<br>    <span class="hljs-type">int</span> x = ctl-&gt;x, y = ctl-&gt;y, w = ctl-&gt;w, h = ctl-&gt;h;<br>    <span class="hljs-keyword">if</span> (!ctl-&gt;sync &amp;&amp; (w == <span class="hljs-number">0</span> || h == <span class="hljs-number">0</span>))<br>        <span class="hljs-keyword">return</span>;<br>    <span class="hljs-type">uint32_t</span>* pixels = ctl-&gt;pixels;<br>    <span class="hljs-type">uint32_t</span>* fb = (<span class="hljs-type">uint32_t</span>*)(<span class="hljs-type">uintptr_t</span>)FB_ADDR;<br>    <span class="hljs-type">uint32_t</span> screen_w = inl(VGACTL_ADDR) &gt;&gt; <span class="hljs-number">16</span>;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = y; i &lt; y + h; i++) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = x; j &lt; x + w; j++) &#123;<br>            fb[screen_w * i + j] = pixels[w * (i - y) + (j - x)];<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (ctl-&gt;sync) &#123;<br>        outl(SYNC_ADDR, <span class="hljs-number">1</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>其它的就没什么区别了：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">void</span> <span class="hljs-title function_">map_write</span><span class="hljs-params">(<span class="hljs-type">paddr_t</span> addr, <span class="hljs-type">int</span> len, <span class="hljs-type">word_t</span> data, IOMap* <span class="hljs-built_in">map</span>)</span> &#123;<br>    assert(len &gt;= <span class="hljs-number">1</span> &amp;&amp; len &lt;= <span class="hljs-number">8</span>);<br>    check_bound(<span class="hljs-built_in">map</span>, addr);<br>    <span class="hljs-type">paddr_t</span> offset = addr - <span class="hljs-built_in">map</span>-&gt;low;<br>    host_write(<span class="hljs-built_in">map</span>-&gt;space + offset, len, data);<br>    invoke_callback(<span class="hljs-built_in">map</span>-&gt;callback, offset, len, <span class="hljs-literal">true</span>);<br>    IFDEF(CONFIG_DTRACE, trace_dwrite(addr, len, data, <span class="hljs-built_in">map</span>););<br>&#125;<br></code></pre></td></tr></table></figure><p>这里写完之后，就结束了。（激活回调函数不起作用）。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这篇文章主要讨论了在 <strong>NEMU</strong> 和 <strong>ysyx</strong> 项目中的三种设备（<strong>串口</strong>、<strong>时钟</strong>、<strong>VGA</strong>）的实现和它们的区别。文章以 <strong>PA2.3</strong> 为背景，模仿 <strong>NEMU</strong> 实现了这三种设备，文章按设备类型进行了详细的实现分析，并对每个设备的访问、触发机制进行了说明。</p><ol><li><p><strong>前言</strong>：</p><ul><li>在 NEMU 中，设备访问是通过统一的接口 <code>io_read</code> 和 <code>io_write</code> 实现的。文章讨论了通过这些接口实现的三种设备（串口、时钟、VGA），它们本质上在 CPU 眼里是读写内存的操作。</li></ul></li><li><p><strong>串口设备</strong>：</p><ul><li>串口的实现通过将字符写入特定的内存地址实现，NEMU 中通过 <code>outb</code> 操作将字符输出到设备地址。这个地址被访问时，会触发一系列的访存操作，最终通过回调函数将字符打印到终端。</li><li>通过 <code>paddr_write</code>，内存访问会检测是否是设备访问，然后调用 <code>serial_io_handler</code> 处理写入并完成输出。</li></ul></li><li><p><strong>时钟设备</strong>：</p><ul><li>时钟和串口的工作原理类似，但时钟设备通过 <code>io_read</code> 读取当前时间。每次读取时会触发相应的回调函数 <code>rtc_io_handler</code>，在读取前更新系统时间寄存器。</li><li>时钟的读取操作首先通过汇编指令执行访存操作，然后调用 <code>mmio_read</code> 来获取时间数据。</li></ul></li><li><p><strong>VGA 设备</strong>：</p><ul><li>VGA 与前两个设备有所不同，它没有依赖回调函数，而是通过周期性的屏幕刷新机制实现。</li><li>文章解释了 <code>vga_update_screen</code> 函数是如何通过定时器定期刷新屏幕，屏幕内容的更新通过写入帧缓冲区 (<code>vmem</code>) 完成。</li><li>每当有新的图形数据写入时，VGA 控制器会将数据写入指定地址，并通过 SDL 进行屏幕刷新。</li></ul></li><li><p><strong>设备间的区别</strong>：</p><ul><li><strong>串口</strong>：依赖回调函数，写入地址时触发输出操作。</li><li><strong>时钟</strong>：在读取时依赖回调函数，读取前准备数据。</li><li><strong>VGA</strong>：不依赖回调函数，而是周期性刷新屏幕。</li></ul></li></ol><h3 id="结论："><a href="#结论：" class="headerlink" title="结论："></a>结论：</h3><p>文章通过分析串口、时钟和 VGA 设备的实现，展示了不同设备在硬件模拟器中的处理机制。虽然这三种设备在 CPU 眼里都表现为内存读写，但它们在触发机制和使用场景上存在显著区别。串口和时钟依赖回调函数，而 VGA 则通过定期更新机制进行屏幕刷新。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;span id=&quot;more&quot;&gt;&lt;/span&gt;

&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;在把 PA2.3 做完之后，顺手把 ysyx 的 npc 中的设备模仿 nemu 也实现了</summary>
      
    
    
    
    <category term="ysyx" scheme="http://blog.luliang.online/categories/ysyx/"/>
    
    <category term="npc" scheme="http://blog.luliang.online/categories/ysyx/npc/"/>
    
    
    <category term="ysyx" scheme="http://blog.luliang.online/tags/ysyx/"/>
    
    <category term="pa2" scheme="http://blog.luliang.online/tags/pa2/"/>
    
    <category term="设备" scheme="http://blog.luliang.online/tags/%E8%AE%BE%E5%A4%87/"/>
    
  </entry>
  
  <entry>
    <title>riscv 函数调用问题</title>
    <link href="http://blog.luliang.online/2024/10/14/riscv%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E9%97%AE%E9%A2%98/"/>
    <id>http://blog.luliang.online/2024/10/14/riscv%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E9%97%AE%E9%A2%98/</id>
    <published>2024-10-14T05:20:40.000Z</published>
    <updated>2025-02-18T13:55:24.283Z</updated>
    
    <content type="html"><![CDATA[<span id="more"></span><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>昨天开组会，助教在会上问了一个问题：A 函数调用 B 函数，s0 的保存是哪一个函数进行的。我觉得这个问题挺熟悉的，因为之前在看 riscv 的 xv6 操作系统时遇到过。</p><h2 id="实验"><a href="#实验" class="headerlink" title="实验"></a>实验</h2><p>main.c:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;add.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">int</span> a = <span class="hljs-number">10</span>, b = <span class="hljs-number">5</span>;<br>    <span class="hljs-type">int</span> c = add(a, b);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>add.h、add.c:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> __ADD_H__</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> __ADD_H__</span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">add</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span>;<br><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;add.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">add</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> &#123;<br>    a += <span class="hljs-number">1</span>;<br>    a += <span class="hljs-number">2</span>;<br>    a += <span class="hljs-number">3</span>;<br>    a += <span class="hljs-number">5</span>;<br>    a += <span class="hljs-number">10</span>;<br>    a += b;<br>    <span class="hljs-keyword">return</span> a;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>Makefile:</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs Makefile">INC_PATH = /home/luyoung/Test/1014_test<br>C_FLAGS = -I<span class="hljs-variable">$(INC_PATH)</span><br><br><span class="hljs-section">build: add.o main.o</span><br>riscv64-linux-gnu-gcc -march=rv32g -mabi=ilp32 -nostdlib -O0 -o main add.o main.o<br><br><span class="hljs-section">add.o: add.c</span><br>bear -- riscv64-linux-gnu-gcc -march=rv32g -mabi=ilp32 -c add.c -o add.o <span class="hljs-variable">$(C_FLAGS)</span> -O0<br><br><span class="hljs-section">main.o: main.c</span><br>bear -- riscv64-linux-gnu-gcc -march=rv32g -mabi=ilp32 -c main.c -o main.o <span class="hljs-variable">$(C_FLAGS)</span> -O0<br><br><span class="hljs-section">dump: main</span><br>riscv64-linux-gnu-objdump -d -M no-aliases main<br><br><span class="hljs-section">clean:</span><br>rm -f *.o main<br><br></code></pre></td></tr></table></figure><p>在编译好了之后：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ make dump<br>riscv64-linux-gnu-objdump -d -M no-aliases main<br><br>main:     file format elf32-littleriscv<br><br><br>Disassembly of section .text:<br><br>000001d8 &lt;add&gt;:<br> 1d8:   fe010113                addi    sp,sp,-32<br> 1dc:   00812e23                sw      s0,28(sp)<br> 1e0:   02010413                addi    s0,sp,32<br> 1e4:   fea42623                sw      a0,-20(s0)<br> 1e8:   feb42423                sw      a1,-24(s0)<br> 1ec:   fec42783                lw      a5,-20(s0)<br> 1f0:   00178793                addi    a5,a5,1<br> 1f4:   fef42623                sw      a5,-20(s0)<br> 1f8:   fec42783                lw      a5,-20(s0)<br> 1fc:   00278793                addi    a5,a5,2<br> 200:   fef42623                sw      a5,-20(s0)<br> 204:   fec42783                lw      a5,-20(s0)<br> 208:   00378793                addi    a5,a5,3<br> 20c:   fef42623                sw      a5,-20(s0)<br> 210:   fec42783                lw      a5,-20(s0)<br> 214:   00578793                addi    a5,a5,5<br> 218:   fef42623                sw      a5,-20(s0)<br> 21c:   fec42783                lw      a5,-20(s0)<br> 220:   00a78793                addi    a5,a5,10<br> 224:   fef42623                sw      a5,-20(s0)<br> 228:   fec42703                lw      a4,-20(s0)<br> 22c:   fe842783                lw      a5,-24(s0)<br> 230:   00f707b3                add     a5,a4,a5<br> 234:   fef42623                sw      a5,-20(s0)<br> 238:   fec42783                lw      a5,-20(s0)<br> 23c:   00078513                addi    a0,a5,0<br> 240:   01c12403                lw      s0,28(sp)<br> 244:   02010113                addi    sp,sp,32<br> 248:   00008067                jalr    zero,0(ra)<br><br>0000024c &lt;main&gt;:<br> 24c:   fe010113                addi    sp,sp,-32<br> 250:   00112e23                sw      ra,28(sp)<br> 254:   00812c23                sw      s0,24(sp)<br> 258:   02010413                addi    s0,sp,32<br> 25c:   00a00793                addi    a5,zero,10<br> 260:   fef42223                sw      a5,-28(s0)<br> 264:   00500793                addi    a5,zero,5<br> 268:   fef42423                sw      a5,-24(s0)<br> 26c:   fe842583                lw      a1,-24(s0)<br> 270:   fe442503                lw      a0,-28(s0)<br> 274:   f65ff0ef                jal     ra,1d8 &lt;add&gt;<br> 278:   fea42623                sw      a0,-20(s0)<br> 27c:   00000793                addi    a5,zero,0<br> 280:   00078513                addi    a0,a5,0<br> 284:   01c12083                lw      ra,28(sp)<br> 288:   01812403                lw      s0,24(sp)<br> 28c:   02010113                addi    sp,sp,32<br> 290:   00008067                jalr    zero,0(ra)<br></code></pre></td></tr></table></figure><p>可以看到，main 函数在刚开始：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs asm">24c:   fe010113                addi    sp,sp,-32<br>250:   00112e23                sw      ra,28(sp)<br>254:   00812c23                sw      s0,24(sp)<br>258:   02010413                addi    s0,sp,32<br></code></pre></td></tr></table></figure><p>首先修改 sp，由于 riscv 的栈空间是向下增长的，这是分配了 32 字节的空间。然后将寄存器 ra、s0 保存到 main 空间，接着重置 s0 为 main 栈空间起始地址。</p><p>我们一般把这个叫做前言。</p><p>sp（栈指针）：通常指向当前栈的顶部，管理局部变量、临时数据、返回地址等。sp 在函数调用时减少，为当前函数的局部变量和参数分配空间。<br>s0（帧指针）：用于指向栈帧的基准位置，便于访问局部变量和参数。它在函数执行期间保持不变，以方便访问栈中的数据。</p><p>这个 ra （return address）是 main 函数的返回地址，因为 main 中也要进行函数调用，而这个过程需要修改 ra 以让 add 函数能正确返回。因此在前言中也要把 ra 保存起来。</p><p>在 main 函数通过 jal 调用 add 之后，首先它会把返回地址，也就是 <code>278:fea42623 sw a0,-20(s0)</code> 这个指令的地址放到 ra 中。然后无条件跳转到 <code>1d8</code>。</p><p>跳到 add 之后，依然要进行函数前言：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs asm">1d8:   fe010113                addi    sp,sp,-32<br>1dc:   00812e23                sw      s0,28(sp)<br>1e0:   02010413                addi    s0,sp,32<br></code></pre></td></tr></table></figure><p>它依然会设置栈帧、帧指针。但是它并没有保存 ra，这是因为 add 函数没有进行函数调用。</p><p>执行完了之后，它就会进入后记：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs asm">23c:   00078513                addi    a0,a5,0<br>240:   01c12403                lw      s0,28(sp)<br>244:   02010113                addi    sp,sp,32<br>248:   00008067                jalr    zero,0(ra)<br></code></pre></td></tr></table></figure><p>可以看到，它会把返回值放到 a0，然后恢复调用它的函数 main 的 sp、s0，然后返回。</p><p>函数返回相当简单，它的 rd 为 0 号寄存器，这意味着它不用保存返回地址，即它是一个函数返回，不是一个函数调用。另外，它的参数 ra 和 ra 是一个值，这意味着它确实要返回。</p><p>下面的C 语言描述更能说明这两个指令的情况：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs C">INSTPAT(<span class="hljs-string">&quot;??????? ????? ????? ??? ????? 11011 11&quot;</span>, jal, J,<br>        s-&gt;dnpc = s-&gt;pc + imm;<br>        R(rd) = s-&gt;pc + <span class="hljs-number">4</span>; IFDEF(<br>            CONFIG_FTRACE,<br>            <span class="hljs-keyword">if</span> (rd != <span class="hljs-number">0</span>) &#123; print_ftrace_call(s-&gt;pc, s-&gt;dnpc); &#125;));<br><br>INSTPAT(<br>    <span class="hljs-string">&quot;??????? ????? ????? 000 ????? 11001 11&quot;</span>, jalr, I,<br>    s-&gt;dnpc = (src1 + imm) &amp;<br>              ~(<span class="hljs-type">word_t</span>)<span class="hljs-number">1</span>;  <span class="hljs-comment">// 在 RISC-V 架构中，指令地址必须对齐到偶数地址</span><br>    <span class="hljs-keyword">if</span> (rd != <span class="hljs-number">0</span>) R(rd) = s-&gt;pc + <span class="hljs-number">4</span>; IFDEF(<br>        CONFIG_FTRACE,<br>        <span class="hljs-keyword">if</span> (rd != <span class="hljs-number">0</span>) &#123;  <span class="hljs-comment">// 跳转</span><br>            print_ftrace_call(s-&gt;pc, s-&gt;dnpc);<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (rd == <span class="hljs-number">0</span> &amp;&amp; src1 == R(<span class="hljs-number">1</span>)) &#123;  <span class="hljs-comment">// src1 和 ra 是否相同</span><br>            print_ftrace_ret(s-&gt;pc, s-&gt;dnpc);<br>        &#125;));<br></code></pre></td></tr></table></figure><p>同样，返回之后，就到了 main 函数的这里：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs asm">278:   fea42623                sw      a0,-20(s0)<br>27c:   00000793                addi    a5,zero,0<br>280:   00078513                addi    a0,a5,0<br>284:   01c12083                lw      ra,28(sp)<br>288:   01812403                lw      s0,24(sp)<br>28c:   02010113                addi    sp,sp,32<br>290:   00008067                jalr    zero,0(ra)<br></code></pre></td></tr></table></figure><p>可以看到，它首先保存返回值，然后把返回值重新放到 a0。之后就是启动函数（调用 main 的函数）的返回了，恢复 ra、s0、sp之后，直接返回。</p><p>可以看到，main 函数调用 add 之后， sp 的开辟、s0 的保存、s0 的设置，都是 add 函数进行的。遵守着<code>谁使用，谁负责整理和维护</code>的规则。比如，main 要调用函数，那么它就得保存 ra，然后给 ra 中放置add的返回地址；add 要返回，那么add 就得恢复 s0、sp。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;span id=&quot;more&quot;&gt;&lt;/span&gt;

&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;昨天开组会，助教在会上问了一个问题：A 函数调用 B 函数，s0 的保存是哪一个函数进行的</summary>
      
    
    
    
    <category term="函数" scheme="http://blog.luliang.online/categories/%E5%87%BD%E6%95%B0/"/>
    
    
    <category term="riscv32" scheme="http://blog.luliang.online/tags/riscv32/"/>
    
    <category term="指令" scheme="http://blog.luliang.online/tags/%E6%8C%87%E4%BB%A4/"/>
    
  </entry>
  
  <entry>
    <title>5 级流水线 CPU 的实现</title>
    <link href="http://blog.luliang.online/2024/10/10/5%E7%BA%A7%E6%B5%81%E6%B0%B4%E7%BA%BFcpu%E7%9A%84%E5%AE%9E%E7%8E%B0/"/>
    <id>http://blog.luliang.online/2024/10/10/5%E7%BA%A7%E6%B5%81%E6%B0%B4%E7%BA%BFcpu%E7%9A%84%E5%AE%9E%E7%8E%B0/</id>
    <published>2024-10-10T12:20:40.000Z</published>
    <updated>2025-02-18T13:55:24.269Z</updated>
    
    <content type="html"><![CDATA[<span id="more"></span><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在 PA2 中，要求实现一个单周期的 CPU，也就是 NPC。这个工作做完了之后，我发现了一本好书，名字叫做《CPU 制作入门：基于 RISC-V 和 Chisel》，是一个日本作者写的。内容非常适合入门，我花了一天时间就看到了单周期，被作者的思路完全影响了，第二天就立即开始重构 NPC，重构好了之后，整个项目看起来很清晰，把能在 ID 阶段做的事情都做了，一共分了 5 个阶段：IF、ID、EXE、MEM、WB。</p><p>之后作者开始做流水线，解决了指令冒险、数据冒险之后，5 级流水就做的差不多了。我按照作者的思路，也为我的 NPC 扩展了 5 级流水，可以通过所有测试案例:</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs txt">[   bubble-sort] PASS<br>[           fib] PASS<br>[   select-sort] PASS<br>[         dummy] PASS<br>[   shuixianhua] PASS<br>[        pascal] PASS<br>[        string] PASS<br>[      mersenne] PASS<br>[           div] PASS<br>[           sum] PASS<br>[       if-else] PASS<br>[           add] PASS<br>[     leap-year] PASS<br>[    quick-sort] PASS<br>[        switch] PASS<br>[        wanshu] PASS<br>[  sub-longlong] PASS<br>[           max] PASS<br>[  add-longlong] PASS<br>[  mul-longlong] PASS<br>[         shift] PASS<br>[    matrix-mul] PASS<br>[         movsx] PASS<br>[           bit] PASS<br>[         mov-c] PASS<br>[     hello-str] PASS<br>[     recursion] PASS<br>[    load-store] PASS<br>[         crc32] PASS<br>[ to-lower-case] PASS<br>[      goldbach] PASS<br>[       unalign] PASS<br>[          fact] PASS<br>[          min3] PASS<br>[         prime] PASS<br></code></pre></td></tr></table></figure><p>这篇文章记录一下我的思考。</p><h2 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h2><p>就像前面说的，一共五个阶段：IF、ID、EXE、MEM、WB。本文用这 5 个阶段阐述。</p><h2 id="IF"><a href="#IF" class="headerlink" title="IF"></a>IF</h2><p>取指，就是往内存模块输送正确的指令地址，期望接收到指令。由于 PC 会受到反馈信号影响，因此这里必须提供一个寄存器：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs Scala"><span class="hljs-keyword">val</span> if_pc_reg = <span class="hljs-type">RegInit</span>(<span class="hljs-type">START_ADDR</span>)<br> <span class="hljs-keyword">val</span> if_pc_plus4 = if_pc_reg + <span class="hljs-number">4.</span><span class="hljs-type">U</span>(<span class="hljs-type">WORD_LEN</span>.<span class="hljs-type">W</span>)<br><br> <span class="hljs-keyword">val</span> exe_br_flg   = <span class="hljs-type">Wire</span>(<span class="hljs-type">Bool</span>())<br> <span class="hljs-keyword">val</span> exe_jmp_flg =  <span class="hljs-type">Wire</span>(<span class="hljs-type">Bool</span>())<br> <span class="hljs-keyword">val</span> exe_br_target = <span class="hljs-type">Wire</span>(<span class="hljs-type">UInt</span>(<span class="hljs-type">WORD_LEN</span>.<span class="hljs-type">W</span>))<br><br> <span class="hljs-keyword">val</span> exe_alu_out = <span class="hljs-type">Wire</span>(<span class="hljs-type">UInt</span>(<span class="hljs-type">WORD_LEN</span>.<span class="hljs-type">W</span>))<br><br> <span class="hljs-keyword">val</span> stall_flg = <span class="hljs-type">Wire</span>(<span class="hljs-type">Bool</span>())<br><br><br> <span class="hljs-comment">// 连接 PC</span><br> <span class="hljs-comment">// 这里使用组合电路</span><br> io.imem.addr := if_pc_reg<br> <span class="hljs-keyword">val</span> if_inst = io.imem.inst<br><br> <span class="hljs-keyword">val</span> if_pc_next = <span class="hljs-type">MuxCase</span>(if_pc_plus4, <span class="hljs-type">Seq</span>(<br>     exe_br_flg -&gt; exe_br_target,<br>     exe_jmp_flg -&gt; exe_alu_out,<br>     (if_inst === <span class="hljs-type">ECALL</span>) -&gt; csr_regfile(<span class="hljs-number">0x305</span>), <span class="hljs-comment">// ecall 跳转到这里进行异常处理</span><br>     stall_flg -&gt; if_pc_reg <span class="hljs-comment">// 数据冒险: 保持pc不变</span><br> ))<br><br> if_pc_reg := if_pc_next <span class="hljs-comment">// 下一个周期更新</span><br><br></code></pre></td></tr></table></figure><p>同时还得给出 PC 的来源。PC 不是随便给的，这很好理解。程序如果不跳转，那么直接运行就好了，每次+4就行。但是程序的执行过程中，跳转、返回等等是必不可少的。因此 PC 有以下几个来源：</p><ul><li>if_pc_reg + 4 &#x2F;&#x2F; 顺序执行</li><li>exe_br_target &#x2F;&#x2F; 分支</li><li>exe_alu_out &#x2F;&#x2F; 跳转</li><li>if_pc_reg &#x2F;&#x2F; 停顿</li></ul><p>分支是指遇到了 B 指令，跳转则是 jal&#x2F;jalr 引起的，至于停顿，这里牵扯到了数据冒险，后面会提到。</p><p>总结一下就是，IF 阶段就负责干一件事：指出下一条指令的地址。至于拿到指令，这是内存自动给出的。</p><h2 id="ID"><a href="#ID" class="headerlink" title="ID"></a>ID</h2><p>指令解码的含义就是，拿到一条指令，对指令进行解码，分析它的位模式。同时求出操作数、寄存器地址。当然，这些信息来源于一条指令的位模式。</p><p>怎么拿到指令？</p><p>如果直接从 IF 阶段往下传，那么下一个周期就会拿到：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs Scala">id_reg_pc := <span class="hljs-type">Mux</span>(stall_flg, id_reg_pc, if_pc_reg) <span class="hljs-comment">// 如果数据冒险：保持</span><br><br>    <span class="hljs-comment">// 指令冒险：if_inst 置为 BUBBLE</span><br>    id_reg_inst := <span class="hljs-type">MuxCase</span>(if_inst, <span class="hljs-type">Seq</span>(<br>        (exe_br_flg || exe_jmp_flg) -&gt; <span class="hljs-type">BUBBLE</span>,<br>        stall_flg -&gt; id_reg_inst <span class="hljs-comment">// 如果数据冒险：保持</span><br>    ))<br><br><br>    <span class="hljs-comment">// 重置指令：如果是冒险指令、冒险数据，那么在当前周期重置为 BUBBLE</span><br>    <span class="hljs-keyword">val</span> id_inst = <span class="hljs-type">Mux</span>((exe_br_flg || exe_jmp_flg || stall_flg), <span class="hljs-type">BUBBLE</span>, id_reg_inst)<br><br>    <span class="hljs-comment">// 解析寄存器地址</span><br>    <span class="hljs-keyword">val</span> id_rs1_addr = id_inst(<span class="hljs-number">19</span>,<span class="hljs-number">15</span>)<br>    <span class="hljs-keyword">val</span> id_rs2_addr = id_inst(<span class="hljs-number">24</span>,<span class="hljs-number">20</span>)<br>    <span class="hljs-keyword">val</span> id_wb_addr  = id_inst(<span class="hljs-number">11</span>,<span class="hljs-number">7</span>)<br>    <span class="hljs-keyword">val</span> mem_wb_data = <span class="hljs-type">Wire</span>(<span class="hljs-type">UInt</span>(<span class="hljs-type">WORD_LEN</span>.<span class="hljs-type">W</span>))<br></code></pre></td></tr></table></figure><p>从多路复用其可以看到，如果不遇到意外，比如没有跳转、数据冒险，就能直接接过接力棒。但是如果遇到了意外，比如分支、数据冒险，那么就不能简单的直接从 IF 拿指令了。</p><p>如果遇到跳转，等等，谁在跳转？</p><p>是 EXE，如果检测到 EXE 在执行一条跳转指令，那么前面处理的 IF、ID不都是白费力气了？</p><p>因此，一旦检测到 EXE 在执行分支、跳转，那么在这个周期，就可以截断 IF 的指令传送，直接让它为 BUBBLE 指令，也就是空指令。下一个周期，这个空指令就会传送到 EXE，这不会改变状态机的任何有效状态。</p><p>如果遇到数据冒险呢？这件事情很常见，也很广泛。以下是一个简单的例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs asm">80000000:00000413          lis0,0<br>80000004:00009117          auipcsp,0x9<br>80000008:ffc10113          addisp,sp,-4 # 80009000 &lt;_end&gt;<br></code></pre></td></tr></table></figure><p>当 EXE 开始执行 auipc 的时候，ID 刚好正在处理 addi。此时，ID 要将操作数 sp 准备好，但是 auipc 执行时，并没有将数据放到寄存器中供给 ID 读取。因为 EX 执行后，数据甚至还没到 MEM，后面还有 WB 阶段。</p><p>这时候，可能会想到，等一个周期，等到 MEM 阶段，将数据直接传送到 ID，而 ID 阶段重新执行一下 addi（之前执行的其实是 BUBBLE）。就好了，这个方法就是 直通 + 停顿。</p><h2 id="等一个周期"><a href="#等一个周期" class="headerlink" title="等一个周期"></a>等一个周期</h2><p>一个状态机，怎么实现等待？</p><p>这是一个好问题，答案是保持输入不变。</p><p>ID 阶段需要向 EXE 提供的底层输入有哪些？</p><ul><li>id_reg_pc</li><li>id_reg_inst</li></ul><p>没错，就这两个：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs Scala">id_reg_pc := <span class="hljs-type">Mux</span>(stall_flg, id_reg_pc, if_pc_reg)<br><br>id_reg_inst := <span class="hljs-type">MuxCase</span>(if_inst, <span class="hljs-type">Seq</span>(<br>    (exe_br_flg || exe_jmp_flg) -&gt; <span class="hljs-type">BUBBLE</span>,<br>    stall_flg -&gt; id_reg_inst <span class="hljs-comment">// 如果数据冒险：保持</span><br>))<br></code></pre></td></tr></table></figure><p>当数据冒险的时候，就保持 id_reg_pc、id_reg_inst。</p><p>然后呢？ID 阶段还有一些操作，这些操作是由组合电路自动完成的，不能乱操作，不能一直经过 EXE、MEM、WB 后影响整个状态机的状态。因此还必须让它空转：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs Scala"><span class="hljs-comment">// 重置指令：如果是冒险指令、冒险数据，那么在当前周期重置为 BUBBLE</span><br><span class="hljs-keyword">val</span> id_inst = <span class="hljs-type">Mux</span>((exe_br_flg || exe_jmp_flg || stall_flg), <span class="hljs-type">BUBBLE</span>, id_reg_inst)<br><br></code></pre></td></tr></table></figure><p>这样，如果是冒险指令、冒险数据，让它decode BUBBLE，当前的 ID、后面的 EX、MEM、WB 自然就不会影响有效状态。</p><h2 id="直通"><a href="#直通" class="headerlink" title="直通"></a>直通</h2><p>直通就是当 MEM、WB 阶段的时候，ID 要访问寄存器，可以不必等到写好之后再访问，可以直接访问：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs Scala"><span class="hljs-keyword">val</span> id_rs1_data = <span class="hljs-type">MuxCase</span>(regfile(id_rs1_addr), <span class="hljs-type">Seq</span>(<br>        (id_rs1_addr === <span class="hljs-number">0.</span><span class="hljs-type">U</span>) -&gt; <span class="hljs-number">0.</span><span class="hljs-type">U</span>(<span class="hljs-type">WORD_LEN</span>.<span class="hljs-type">W</span>),<br>        <span class="hljs-comment">// 从 MEM 直通</span><br>        ((id_rs1_addr === mem_reg_wb_addr) &amp;&amp; (mem_reg_rf_wen === <span class="hljs-type">REN_S</span>)) -&gt; mem_wb_data,<br>        <span class="hljs-comment">// 从 WB 直通</span><br>        ((id_rs1_addr === wb_reg_wb_addr) &amp;&amp; (wb_reg_rf_wen === <span class="hljs-type">REN_S</span>)) -&gt; wb_reg_wb_data<br><br>    ))<br><span class="hljs-keyword">val</span> id_rs2_data = <span class="hljs-type">MuxCase</span>(regfile(id_rs2_addr), <span class="hljs-type">Seq</span>(<br>        (id_rs2_addr === <span class="hljs-number">0.</span><span class="hljs-type">U</span>) -&gt; <span class="hljs-number">0.</span><span class="hljs-type">U</span>(<span class="hljs-type">WORD_LEN</span>.<span class="hljs-type">W</span>),<br>        <span class="hljs-comment">// 从 MEM 直通</span><br>        ((id_rs2_addr === mem_reg_wb_addr) &amp;&amp; (mem_reg_rf_wen === <span class="hljs-type">REN_S</span>)) -&gt; mem_wb_data,<br>        <span class="hljs-comment">// 从 WB 直通</span><br>        ((id_rs2_addr === wb_reg_wb_addr) &amp;&amp; (wb_reg_rf_wen === <span class="hljs-type">REN_S</span>)) -&gt; wb_reg_wb_data<br>    ))<br></code></pre></td></tr></table></figure><p>这样就完成了指令冒险，数据冒险的处理。</p><p>总结：如果遇到指令冒险，那么就等待 EXE 执行一周期，这样，EXE 将会再接下来的两个周期执行两次 BUBBLE，第三个周期才会执行到跳转的目标指令。原因就是 ID 在当前 decode 了 BUBBLE化的指令，同时 ID 的下一个周期还是 BUBBLE，下下个周期才是 IF 传上来的 目标指令。至于 IF，当前传送的指令被BUBBLE 重置，下一个周期自然就是 BUBBLE 了，当前传送的指令也没用，但是下一个周期传送的指令就是目标指令了。</p><p>如果是数据冒险，那么情况就有点复杂。</p><p>如果可以直通，那么就直通；如果不能直通，那么就等待一个周期后直通。等待的含义就是保持状态不变，IF 等待、ID 等待。</p><p>IF 等待只需要保持 if_pc_reg 不变就行了，也就是将 if_pc_next 置为 if_pc_reg。<br>ID 保持，只需要保持 id_reg_pc、id_reg_inst 不变就行了。另外再执行一下 BUBBLE化的指令，这是幂等指令，执行 N 次（N &gt;&#x3D; 0）都不会改变状态机有效状态。</p><p>至于 MEM、WB 就很简单了，没什么可讲的了。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;span id=&quot;more&quot;&gt;&lt;/span&gt;

&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;在 PA2 中，要求实现一个单周期的 CPU，也就是 NPC。这个工作做完了之后，我发现了</summary>
      
    
    
    
    <category term="PA2" scheme="http://blog.luliang.online/categories/PA2/"/>
    
    <category term="CPU" scheme="http://blog.luliang.online/categories/PA2/CPU/"/>
    
    
    <category term="Chisel" scheme="http://blog.luliang.online/tags/Chisel/"/>
    
    <category term="riscv32" scheme="http://blog.luliang.online/tags/riscv32/"/>
    
  </entry>
  
  <entry>
    <title>nemu 工作原理解析</title>
    <link href="http://blog.luliang.online/2024/09/26/nemu%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/"/>
    <id>http://blog.luliang.online/2024/09/26/nemu%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/</id>
    <published>2024-09-26T12:20:40.000Z</published>
    <updated>2025-02-18T13:55:24.282Z</updated>
    
    <content type="html"><![CDATA[<span id="more"></span><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本人在实现 <code>npc</code> 的仿真环境的基础设施的时候，发现要重新写很多东西，好消息是这些东西已经在 <code>nemu</code> 中实现了。但是把它重新部署到 <code>npc</code> 却不是一件简单的事情，要对文件组织、编译流程有一个深刻的认识。</p><h2 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h2>]]></content>
    
    
      
      
    <summary type="html">&lt;span id=&quot;more&quot;&gt;&lt;/span&gt;

&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;本人在实现 &lt;code&gt;npc&lt;/code&gt; 的仿真环境的基础设施的时候，发现要重新写很多</summary>
      
    
    
    
    <category term="PA2" scheme="http://blog.luliang.online/categories/PA2/"/>
    
    <category term="模拟器" scheme="http://blog.luliang.online/categories/PA2/%E6%A8%A1%E6%8B%9F%E5%99%A8/"/>
    
    
    <category term="nemu" scheme="http://blog.luliang.online/tags/nemu/"/>
    
    <category term="仿真" scheme="http://blog.luliang.online/tags/%E4%BB%BF%E7%9C%9F/"/>
    
  </entry>
  
  <entry>
    <title>DPI-C 传递参数的问题</title>
    <link href="http://blog.luliang.online/2024/09/25/DPI-C%E4%BC%A0%E5%8F%82%E7%9A%84%E9%97%AE%E9%A2%98/"/>
    <id>http://blog.luliang.online/2024/09/25/DPI-C%E4%BC%A0%E5%8F%82%E7%9A%84%E9%97%AE%E9%A2%98/</id>
    <published>2024-09-25T12:20:40.000Z</published>
    <updated>2025-02-18T13:55:24.273Z</updated>
    
    <content type="html"><![CDATA[<span id="more"></span><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>DPI-C 是 Verilator 提供的一种机制，可以在 Verilog 代码中调用 C&#x2F;C++ 中定义的 C 语言函数。这为 Verilog 与仿真环境（C&#x2F;C++）的交互提供了方便。</p><hr><h2 id="DPI-C-的基本使用步骤"><a href="#DPI-C-的基本使用步骤" class="headerlink" title="DPI-C 的基本使用步骤"></a>DPI-C 的基本使用步骤</h2><ol><li><p><strong>在 Verilog 中声明 C 函数</strong></p><p>使用 <code>import &quot;DPI-C&quot;</code> 语句在 Verilog 中声明要调用的 C 函数。语法如下：</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;DPI-C&quot;</span> <span class="hljs-keyword">function</span> &lt;返回类型&gt; &lt;函数名&gt;(&lt;参数列表&gt;);<br></code></pre></td></tr></table></figure><ul><li><code>&lt;返回类型&gt;</code>：函数的返回类型，可以是 <code>void</code> 或基本数据类型。</li><li><code>&lt;函数名&gt;</code>：C 函数的名称。</li><li><code>&lt;参数列表&gt;</code>：函数的参数，包括 <code>input</code>、<code>output</code>、<code>inout</code>，以及对应的类型。</li></ul></li><li><p><strong>在 Verilog 中调用 C 函数</strong></p><p>在需要的位置，直接调用已声明的 C 函数：</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs verilog">&lt;函数名&gt;(&lt;参数列表&gt;);<br></code></pre></td></tr></table></figure></li><li><p><strong>在 C&#x2F;C++ 中实现该函数</strong></p><p>在 C 或 C++ 文件中，按照声明的参数和返回类型，实现对应的函数：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">extern</span> <span class="hljs-string">&quot;C&quot;</span> &lt;返回类型&gt; &lt;函数名&gt;(&lt;参数列表&gt;) &#123;<br>    <span class="hljs-comment">// 函数实现</span><br>&#125;<br></code></pre></td></tr></table></figure><ul><li><code>extern &quot;C&quot;</code>：防止 C++ 编译器对函数名进行重整（Name Mangling），确保函数名在链接时与 Verilog 中的声明一致。</li></ul></li></ol><hr><h2 id="示例：call-c-function-函数的应用"><a href="#示例：call-c-function-函数的应用" class="headerlink" title="示例：call_c_function 函数的应用"></a>示例：<code>call_c_function</code> 函数的应用</h2><h3 id="1-在-Verilog-中声明-call-c-function"><a href="#1-在-Verilog-中声明-call-c-function" class="headerlink" title="1. 在 Verilog 中声明 call_c_function"></a>1. 在 Verilog 中声明 <code>call_c_function</code></h3><p>在文件声明一个名为 <code>call_c_function</code> 的 C 函数：</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">module</span> MyBlackBox(<br>    <span class="hljs-keyword">input</span>  <span class="hljs-keyword">logic</span> [<span class="hljs-number">31</span>:<span class="hljs-number">0</span>] input1,<br>    <span class="hljs-keyword">input</span>  <span class="hljs-keyword">logic</span>        clock,<br>    <span class="hljs-keyword">input</span>  <span class="hljs-keyword">logic</span>        reset,<br>    <span class="hljs-keyword">output</span> <span class="hljs-keyword">logic</span> [<span class="hljs-number">31</span>:<span class="hljs-number">0</span>] output1<br>);<br>    <span class="hljs-keyword">import</span> <span class="hljs-string">&quot;DPI-C&quot;</span> <span class="hljs-keyword">function</span> <span class="hljs-keyword">void</span> call_c_function(<span class="hljs-keyword">input</span> <span class="hljs-keyword">int</span> in, <span class="hljs-keyword">output</span> <span class="hljs-keyword">int</span> out);<br><span class="hljs-keyword">endmodule</span><br><br></code></pre></td></tr></table></figure><h3 id="2-在-Verilog-中调用-call-c-function"><a href="#2-在-Verilog-中调用-call-c-function" class="headerlink" title="2. 在 Verilog 中调用 call_c_function"></a>2. 在 Verilog 中调用 <code>call_c_function</code></h3><p>在同一文件中，通过以下方式调用该函数：</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">always_ff</span> @(<span class="hljs-keyword">posedge</span> clock <span class="hljs-keyword">or</span> <span class="hljs-keyword">posedge</span> reset) <span class="hljs-keyword">begin</span><br>        <span class="hljs-keyword">if</span> (reset) <span class="hljs-keyword">begin</span><br>            output1 &lt;= <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">end</span> <span class="hljs-keyword">else</span> <span class="hljs-keyword">begin</span><br>            <span class="hljs-keyword">int</span> temp;<br>            call_c_function(input1, temp);<br>            output1 &lt;= temp;<br>        <span class="hljs-keyword">end</span><br>    <span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><ul><li><strong>说明</strong>：<ul><li>在组合逻辑块中，每当输入信号位非 reset 时调用 <code>call_c_function</code>。</li><li>input1、temp 都是参数，其中 temp 类似于 C++ 中的引用 ，在函数中对temp修改，它的值就会改变，这点非常关键，一定要注意。</li></ul></li></ul><h3 id="3-在-C-中实现-call-c-function"><a href="#3-在-C-中实现-call-c-function" class="headerlink" title="3. 在 C++ 中实现 call_c_function"></a>3. 在 C++ 中实现 <code>call_c_function</code></h3><p>在文件 <code>main.cpp</code> 中，实现该函数：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">extern</span> <span class="hljs-string">&quot;C&quot;</span> <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">call_c_function</span><span class="hljs-params">(<span class="hljs-type">uint32_t</span> input1, <span class="hljs-type">uint32_t</span>* output1)</span> </span>&#123;<br>    <span class="hljs-type">uint32_t</span> out_val = input1 + <span class="hljs-number">1</span>; <span class="hljs-comment">// 示例处理</span><br>    *output1 = out_val;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;output1 in func:%u\n&quot;</span>,out_val);<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><strong>函数逻辑</strong>：<ul><li>可以看到，这里的形参和声明这个函数的时候，参数并不一样，这是什么现象呢？后面会讨论；</li><li>将 input+1 赋值给 out_val；</li><li>再将 output 修改为 outval；</li><li>打印一些信息。</li></ul></li></ul><h3 id="4-仿真过程中的调用"><a href="#4-仿真过程中的调用" class="headerlink" title="4. 仿真过程中的调用"></a>4. 仿真过程中的调用</h3><p>在仿真过程中，每次调用 <code>eval()</code> 方法评估 Verilog 设计时，如果 <code>call_c_function</code> 被触发，就会调用对应的 C++ 函数。这实现了 Verilog 代码对 C 函数的调用，使得硬件仿真能够与软件逻辑进行交互。</p><hr><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p>这里需要准备：<br><code>./main.cpp</code>:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdint.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;VMyModule.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;verilated.h&quot;</span></span><br><br><span class="hljs-keyword">extern</span> <span class="hljs-string">&quot;C&quot;</span> <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">call_c_function</span><span class="hljs-params">(<span class="hljs-type">uint32_t</span> input1, <span class="hljs-type">uint32_t</span>* output1)</span> </span>&#123;<br>    <span class="hljs-type">uint32_t</span> out_val = input1 + <span class="hljs-number">1</span>; <span class="hljs-comment">// 示例处理</span><br>    *output1 = out_val;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;output1 in func:%u\n&quot;</span>,out_val);<br>&#125;<br><br><span class="hljs-type">static</span> VMyModule* top = <span class="hljs-literal">NULL</span>;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">step</span><span class="hljs-params">()</span> </span>&#123;<br>    top-&gt;clock = <span class="hljs-number">0</span>;<br>    top-&gt;<span class="hljs-built_in">eval</span>();<br>    top-&gt;clock = <span class="hljs-number">1</span>;<br>    top-&gt;<span class="hljs-built_in">eval</span>();<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">reset</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>&#123;<br>    top-&gt;reset = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span> (n--) &#123;<br>        <span class="hljs-built_in">step</span>();<br>    &#125;<br>    top-&gt;reset = <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span>* argv[])</span> </span>&#123;<br>    Verilated::<span class="hljs-built_in">commandArgs</span>(argc, argv);<br>    top = <span class="hljs-keyword">new</span> VMyModule;<br><br>    <span class="hljs-built_in">reset</span>(<span class="hljs-number">1</span>);  <span class="hljs-comment">// 初始化</span><br><br>    <span class="hljs-comment">// 设置输入信号</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; ++i) &#123;<br>        top-&gt;io_in = i; <span class="hljs-comment">// 更新输入信号</span><br>        <span class="hljs-built_in">step</span>(); <span class="hljs-comment">// 进行一步仿真</span><br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Input: %u, Output: %u\n&quot;</span>, top-&gt;io_in, top-&gt;io_out);<br><br>    &#125;<br><br>    <span class="hljs-keyword">delete</span> top; <span class="hljs-comment">// 释放资源</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><p><code>./MyModule.scala</code>:</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs Scala"><span class="hljs-keyword">import</span> chisel3._<br><br><span class="hljs-comment">// 定义的模块可以直接在里面引入黑盒</span><br><span class="hljs-comment">// 这个也算是顶层模块</span><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyModule</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Module</span> </span>&#123;<br>    <span class="hljs-keyword">val</span> io = <span class="hljs-type">IO</span>(<span class="hljs-keyword">new</span> <span class="hljs-type">Bundle</span> &#123;<br>    <span class="hljs-keyword">val</span> in = <span class="hljs-type">Input</span>(<span class="hljs-type">UInt</span>(<span class="hljs-number">32.</span><span class="hljs-type">W</span>))<br>    <span class="hljs-keyword">val</span> out = <span class="hljs-type">Output</span>(<span class="hljs-type">UInt</span>(<span class="hljs-number">32.</span><span class="hljs-type">W</span>))<br>  &#125;)<br><br>  <span class="hljs-keyword">val</span> blackBox = <span class="hljs-type">Module</span>(<span class="hljs-keyword">new</span> <span class="hljs-type">MyBlackBox</span>)<br><br>  <span class="hljs-comment">// 在这里引入我们刚包装好的黑盒，连接好引脚即可</span><br>  blackBox.io.clock := clock<br>  blackBox.io.reset := reset<br>  blackBox.io.input1 := io.in<br>  io.out := blackBox.io.output1<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">object</span> <span class="hljs-title">MyModule</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">App</span> </span>&#123;<br>  (<span class="hljs-keyword">new</span> chisel3.stage.<span class="hljs-type">ChiselStage</span>).emitVerilog(<span class="hljs-keyword">new</span> <span class="hljs-type">MyModule</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p><code>./MyBlackBox.scala</code>:</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs Scala"><span class="hljs-keyword">import</span> chisel3._<br><span class="hljs-keyword">import</span> chisel3.util._<br><span class="hljs-keyword">import</span> chisel3.experimental._<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyBlackBox</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">BlackBox</span> <span class="hljs-keyword">with</span> <span class="hljs-title">HasBlackBoxPath</span> </span>&#123;<br>  <span class="hljs-keyword">val</span> io = <span class="hljs-type">IO</span>(<span class="hljs-keyword">new</span> <span class="hljs-type">Bundle</span> &#123;<br>    <span class="hljs-keyword">val</span> clock = <span class="hljs-type">Input</span>(<span class="hljs-type">Clock</span>())<br>    <span class="hljs-keyword">val</span> reset = <span class="hljs-type">Input</span>(<span class="hljs-type">Bool</span>())<br>    <span class="hljs-keyword">val</span> input1 = <span class="hljs-type">Input</span>(<span class="hljs-type">UInt</span>(<span class="hljs-number">32.</span><span class="hljs-type">W</span>))<br>    <span class="hljs-keyword">val</span> output1 = <span class="hljs-type">Output</span>(<span class="hljs-type">UInt</span>(<span class="hljs-number">32.</span><span class="hljs-type">W</span>))<br>  &#125;)<br><br>&#125;<br><br></code></pre></td></tr></table></figure><p><code>./aaa/MyBlackBox.sc</code>:</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs Verilog"><span class="hljs-keyword">module</span> MyBlackBox(<br>    <span class="hljs-keyword">input</span>  <span class="hljs-keyword">logic</span> [<span class="hljs-number">31</span>:<span class="hljs-number">0</span>] input1,<br>    <span class="hljs-keyword">input</span>  <span class="hljs-keyword">logic</span>        clock,<br>    <span class="hljs-keyword">input</span>  <span class="hljs-keyword">logic</span>        reset,<br>    <span class="hljs-keyword">output</span> <span class="hljs-keyword">logic</span> [<span class="hljs-number">31</span>:<span class="hljs-number">0</span>] output1<br>);<br>    <span class="hljs-keyword">import</span> <span class="hljs-string">&quot;DPI-C&quot;</span> <span class="hljs-keyword">function</span> <span class="hljs-keyword">void</span> call_c_function(<span class="hljs-keyword">input</span> <span class="hljs-keyword">int</span> in, <span class="hljs-keyword">output</span> <span class="hljs-keyword">int</span> out);<br><br>    <span class="hljs-keyword">always_ff</span> @(<span class="hljs-keyword">posedge</span> clock <span class="hljs-keyword">or</span> <span class="hljs-keyword">posedge</span> reset) <span class="hljs-keyword">begin</span><br>        <span class="hljs-keyword">if</span> (reset) <span class="hljs-keyword">begin</span><br>            output1 &lt;= <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">end</span> <span class="hljs-keyword">else</span> <span class="hljs-keyword">begin</span><br>            <span class="hljs-keyword">int</span> temp;<br>            call_c_function(input1, temp);<br>            output1 &lt;= temp;<br>        <span class="hljs-keyword">end</span><br>    <span class="hljs-keyword">end</span><br><span class="hljs-keyword">endmodule</span><br><br></code></pre></td></tr></table></figure><p>最后一个就是 <code>./Makefile</code> 了：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs Makefile"><span class="hljs-section">hdl:</span><br>@sbt clean<br>@sbt run<br><br><span class="hljs-section">build:</span><br>bear -- verilator --cc MyModule.v --exe --build main.cpp -I/home/luyoung/Test/BlackBox/aaa<br><br><span class="hljs-section">clean:</span><br>@rm -rf obj_dir project target<br><br><span class="hljs-section">run:</span><br>./obj_dir/VMyModule<br><br><span class="hljs-meta"><span class="hljs-keyword">.PHONY</span>: hdl build clean</span><br><br></code></pre></td></tr></table></figure><p>直接运行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ make hdl<br>[info] welcome to sbt 1.10.2 (Private Build Java 1.8.0_422)<br>[info] loading project definition from /home/luyoung/Test/BlackBox/project<br>[info] loading settings <span class="hljs-keyword">for</span> project blackbox from build.sbt ...<br>[info] <span class="hljs-built_in">set</span> current project to blackbox (<span class="hljs-keyword">in</span> build file:/home/luyoung/Test/BlackBox/)<br>[success] Total time: 0 s, completed Sep 25, 2024 9:28:55 PM<br>[info] welcome to sbt 1.10.2 (Private Build Java 1.8.0_422)<br>[info] loading project definition from /home/luyoung/Test/BlackBox/project<br>[info] loading settings <span class="hljs-keyword">for</span> project blackbox from build.sbt ...<br>[info] <span class="hljs-built_in">set</span> current project to blackbox (<span class="hljs-keyword">in</span> build file:/home/luyoung/Test/BlackBox/)<br>[info] compiling 2 Scala sources to /home/luyoung/Test/BlackBox/target/scala-2.12/classes ...<br>[info] running MyModule<br>[success] Total time: 6 s, completed Sep 25, 2024 9:29:04 PM<br><br>luyoung at luyoung-desktop <span class="hljs-keyword">in</span> ~/Test/BlackBox<br>$ make build<br>bear -- verilator --cc MyModule.v --exe --build main.cpp -I/home/luyoung/Test/BlackBox/aaa<br>make[1]: Entering directory <span class="hljs-string">&#x27;/home/luyoung/Test/BlackBox/obj_dir&#x27;</span><br>ccache g++  -I.  -MMD -I/usr/local/share/verilator/include -I/usr/local/share/verilator/include/vltstd -DVM_COVERAGE=0 -DVM_SC=0 -DVM_TRACE=0 -DVM_TRACE_FST=0 -DVM_TRACE_VCD=0 -faligned-new -fcf-protection=none -Wno-bool-operation -Wno-sign-compare -Wno-uninitialized -Wno-unused-but-set-variable -Wno-unused-parameter -Wno-unused-variable -Wno-shadow       -Os -c -o main.o ../main.cpp<br>ccache g++  -I.  -MMD -I/usr/local/share/verilator/include -I/usr/local/share/verilator/include/vltstd -DVM_COVERAGE=0 -DVM_SC=0 -DVM_TRACE=0 -DVM_TRACE_FST=0 -DVM_TRACE_VCD=0 -faligned-new -fcf-protection=none -Wno-bool-operation -Wno-sign-compare -Wno-uninitialized -Wno-unused-but-set-variable -Wno-unused-parameter -Wno-unused-variable -Wno-shadow       -Os -c -o verilated.o /usr/local/share/verilator/include/verilated.cpp<br>ccache g++  -I.  -MMD -I/usr/local/share/verilator/include -I/usr/local/share/verilator/include/vltstd -DVM_COVERAGE=0 -DVM_SC=0 -DVM_TRACE=0 -DVM_TRACE_FST=0 -DVM_TRACE_VCD=0 -faligned-new -fcf-protection=none -Wno-bool-operation -Wno-sign-compare -Wno-uninitialized -Wno-unused-but-set-variable -Wno-unused-parameter -Wno-unused-variable -Wno-shadow       -Os -c -o verilated_dpi.o /usr/local/share/verilator/include/verilated_dpi.cpp<br>ccache g++  -I.  -MMD -I/usr/local/share/verilator/include -I/usr/local/share/verilator/include/vltstd -DVM_COVERAGE=0 -DVM_SC=0 -DVM_TRACE=0 -DVM_TRACE_FST=0 -DVM_TRACE_VCD=0 -faligned-new -fcf-protection=none -Wno-bool-operation -Wno-sign-compare -Wno-uninitialized -Wno-unused-but-set-variable -Wno-unused-parameter -Wno-unused-variable -Wno-shadow       -Os -c -o verilated_threads.o /usr/local/share/verilator/include/verilated_threads.cpp<br>/usr/bin/python3 /usr/local/share/verilator/bin/verilator_includer -DVL_INCLUDE_OPT=include VMyModule.cpp VMyModule___024root__DepSet_h95824ea7__0.cpp VMyModule___024root__DepSet_hba0a4a14__0.cpp VMyModule__Dpi.cpp VMyModule___024root__Slow.cpp VMyModule___024root__DepSet_h95824ea7__0__Slow.cpp VMyModule___024root__DepSet_hba0a4a14__0__Slow.cpp VMyModule__Syms.cpp &gt; VMyModule__ALL.cpp<br>ccache g++  -I.  -MMD -I/usr/local/share/verilator/include -I/usr/local/share/verilator/include/vltstd -DVM_COVERAGE=0 -DVM_SC=0 -DVM_TRACE=0 -DVM_TRACE_FST=0 -DVM_TRACE_VCD=0 -faligned-new -fcf-protection=none -Wno-bool-operation -Wno-sign-compare -Wno-uninitialized -Wno-unused-but-set-variable -Wno-unused-parameter -Wno-unused-variable -Wno-shadow       -Os -c -o VMyModule__ALL.o VMyModule__ALL.cpp<br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;&quot;</span> &gt; VMyModule__ALL.verilator_deplist.tmp<br>Archive ar -rcs VMyModule__ALL.a VMyModule__ALL.o<br>g++    main.o verilated.o verilated_dpi.o verilated_threads.o VMyModule__ALL.a    -pthread -lpthread -latomic   -o VMyModule<br><span class="hljs-built_in">rm</span> VMyModule__ALL.verilator_deplist.tmp<br>make[1]: Leaving directory <span class="hljs-string">&#x27;/home/luyoung/Test/BlackBox/obj_dir&#x27;</span><br><br>luyoung at luyoung-desktop <span class="hljs-keyword">in</span> ~/Test/BlackBox<br>$ make run<br>./obj_dir/VMyModule<br>output1 <span class="hljs-keyword">in</span> func:1<br>Input: 0, Output: 1<br>output1 <span class="hljs-keyword">in</span> func:2<br>Input: 1, Output: 2<br>output1 <span class="hljs-keyword">in</span> func:3<br>Input: 2, Output: 3<br>output1 <span class="hljs-keyword">in</span> func:4<br>Input: 3, Output: 4<br>output1 <span class="hljs-keyword">in</span> func:5<br>Input: 4, Output: 5<br>output1 <span class="hljs-keyword">in</span> func:6<br>Input: 5, Output: 6<br>output1 <span class="hljs-keyword">in</span> func:7<br>Input: 6, Output: 7<br>output1 <span class="hljs-keyword">in</span> func:8<br>Input: 7, Output: 8<br>output1 <span class="hljs-keyword">in</span> func:9<br>Input: 8, Output: 9<br>output1 <span class="hljs-keyword">in</span> func:10<br>Input: 9, Output: 10<br></code></pre></td></tr></table></figure><p>可以看到，顺利得传递了参数，并且类似于引用一样，修改了黑盒子处的值 <code>temp</code>，它影响了 <code>output1</code>:</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs Verilog"><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;DPI-C&quot;</span> <span class="hljs-keyword">function</span> <span class="hljs-keyword">void</span> call_c_function(<span class="hljs-keyword">input</span> <span class="hljs-keyword">int</span> in, <span class="hljs-keyword">output</span> <span class="hljs-keyword">int</span> out);<br><br>    <span class="hljs-keyword">always_ff</span> @(<span class="hljs-keyword">posedge</span> clock <span class="hljs-keyword">or</span> <span class="hljs-keyword">posedge</span> reset) <span class="hljs-keyword">begin</span><br>        <span class="hljs-keyword">if</span> (reset) <span class="hljs-keyword">begin</span><br>            output1 &lt;= <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">end</span> <span class="hljs-keyword">else</span> <span class="hljs-keyword">begin</span><br>            <span class="hljs-keyword">int</span> temp;<br>            call_c_function(input1, temp);<br>            output1 &lt;= temp;<br>        <span class="hljs-keyword">end</span><br>    <span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><h2 id="讨论类似于引用一样的传值"><a href="#讨论类似于引用一样的传值" class="headerlink" title="讨论类似于引用一样的传值"></a>讨论类似于引用一样的传值</h2><p>这是一件很少见的事情，考虑到这是 C++，我试图用类型隐式转换来解释。</p><p>这里的函数声明有什么不对吗：</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs Verilog">...<br><span class="hljs-keyword">input</span>  <span class="hljs-keyword">logic</span> [<span class="hljs-number">31</span>:<span class="hljs-number">0</span>] input1,<br>...<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;DPI-C&quot;</span> <span class="hljs-keyword">function</span> <span class="hljs-keyword">void</span> call_c_function(<span class="hljs-keyword">input</span> <span class="hljs-keyword">int</span> in, <span class="hljs-keyword">output</span> <span class="hljs-keyword">int</span> out);<br><br>...<br>        <span class="hljs-keyword">int</span> temp;<br>        call_c_function(input1, temp);<br>...<br></code></pre></td></tr></table></figure><p>这里都声明为 int 类型，但是调用的时候，很明显往里面传送了一个 32 位的 input 类型。</p><p>另外，函数的定义更为奇怪：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">extern</span> <span class="hljs-string">&quot;C&quot;</span> <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">call_c_function</span><span class="hljs-params">(<span class="hljs-type">uint32_t</span> input1, <span class="hljs-type">uint32_t</span>* output1)</span> </span>&#123;<br>    <span class="hljs-type">uint32_t</span> out_val = input1 + <span class="hljs-number">1</span>; <span class="hljs-comment">// 示例处理</span><br>    *output1 = out_val;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;output1 in func:%u\n&quot;</span>,out_val);<br>&#125;<br></code></pre></td></tr></table></figure><p>函数的定义，形参直接变成 <code>uint32_t</code>、<code>uint32_t*</code> 了。</p><p>怎么理解这件事呢？</p><p>经过查阅手册，SystemVerilog 和 Verilog 数据类型：</p><table><thead><tr><th><strong>数据类型</strong></th><th><strong>描述</strong></th><th><strong>位宽</strong></th><th><strong>有符号&#x2F;无符号</strong></th><th><strong>两态&#x2F;四态</strong></th></tr></thead><tbody><tr><td><code>shortint</code></td><td>16 位有符号整数</td><td>16 位</td><td>有符号</td><td>两态</td></tr><tr><td><code>int</code></td><td>32 位有符号整数</td><td>32 位</td><td>有符号</td><td>两态</td></tr><tr><td><code>longint</code></td><td>64 位有符号整数</td><td>64 位</td><td>有符号</td><td>两态</td></tr><tr><td><code>byte</code></td><td>8 位有符号整数或 ASCII 码字符</td><td>8 位</td><td>有符号</td><td>两态</td></tr><tr><td><code>bit</code></td><td>用户定义的向量尺寸</td><td>用户定义</td><td>无符号</td><td>两态</td></tr><tr><td><code>logic</code></td><td>用户定义的向量尺寸</td><td>用户定义</td><td>无符号</td><td>四态</td></tr><tr><td><code>reg</code></td><td>Verilog-2001 用户定义的向量尺寸</td><td>用户定义</td><td>无符号</td><td>四态</td></tr><tr><td><code>integer</code></td><td>Verilog-2001 32 位有符号整数</td><td>32 位</td><td>有符号</td><td>四态</td></tr><tr><td><code>time</code></td><td>Verilog-2001 64 位无符号整数</td><td>64 位</td><td>无符号</td><td>四态</td></tr></tbody></table><p>可以看到，在 Verilog 中声明的 <code>int</code> 类型是 32 位的，这就很好理解了。</p><p>看到的类型不匹配实际上在位宽和内存布局上是兼容的。 Verilog 的 int 和 C 的 uint32_t 在 DPI 传递过程中能够正确映射。使用固定宽度的整数类型（如 uint32_t）是确保跨平台兼容性的良好实践。</p><p>也就是说，只要宽度一样，就可以做良好的映射。另外这里的指针操作很奇怪，明明传送的是一个变量，怎么就修改了呢？</p><p>在 Verilog 中调用 <code>call_c_function(input1, temp);</code> 时，<code>temp</code> 是一个普通的 <code>int</code> 变量，看起来是按值传递的。但是在 C 函数中，参数是 <code>uint32_t* output1</code>，即一个指针，并且在函数中通过这个指针修改了 <code>output1</code> 的值。困惑的是，为什么在 Verilog 中传递一个值，C 函数却能通过指针修改它，<code>temp</code> 的值也因此被改变。</p><p><strong>这是因为在 SystemVerilog DPI 中，参数的传递方式取决于参数的方向（<code>input</code>、<code>output</code>）。</strong></p><hr><p><strong>详细解释如下：</strong></p><ol><li><p><strong>Verilog 中的函数声明和调用：</strong></p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;DPI-C&quot;</span> <span class="hljs-keyword">function</span> <span class="hljs-keyword">void</span> call_c_function(<span class="hljs-keyword">input</span> <span class="hljs-keyword">int</span> in, <span class="hljs-keyword">output</span> <span class="hljs-keyword">int</span> out);<br><br>...<br><br><span class="hljs-keyword">int</span> temp;<br>call_c_function(input1, temp);<br></code></pre></td></tr></table></figure><ul><li><code>input1</code>：作为 <code>input</code> 参数，按值传递。</li><li><code>temp</code>：作为 <code>output</code> 参数，虽然在代码中看起来是按值传递，但实际上是按引用传递。</li></ul></li><li><p><strong>参数传递方式：</strong></p><ul><li><strong><code>input</code> 参数：</strong> 按值传递，C 函数<strong>接收的是该参数的副本</strong>，无法修改调用者的变量。</li><li><strong><code>output</code> 参数：</strong> 按引用传递，C 函数接收的是<strong>一个指向调用者变量的指针</strong>，可以修改该变量的值。</li></ul></li><li><p><strong>在 C 函数中的定义：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">extern</span> <span class="hljs-string">&quot;C&quot;</span> <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">call_c_function</span><span class="hljs-params">(<span class="hljs-type">uint32_t</span> input1, <span class="hljs-type">uint32_t</span>* output1)</span> </span>&#123;<br>    <span class="hljs-type">uint32_t</span> out_val = input1 + <span class="hljs-number">1</span>; <span class="hljs-comment">// 示例处理</span><br>    *output1 = out_val;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;output1 in func:%u\n&quot;</span>, out_val);<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><code>input1</code>：接收 <code>input</code> 参数的值。</li><li><code>output1</code>：接收 <code>output</code> 参数的指针，允许修改调用者的变量。</li></ul></li><li><p><strong>为什么 <code>temp</code> 的值会被修改：</strong></p><ul><li>在 Verilog 中，传递了变量 <code>temp</code>，对应于 <code>output</code> 参数。</li><li>SystemVerilog 编译器在编译时，知道 <code>out</code> 是一个 <code>output</code> 参数，会自动将 <code>temp</code> 的地址传递给 C 函数。</li><li>因此，C 函数中的 <code>uint32_t* output1</code> 实际上指向 Verilog 中的变量 <code>temp</code>。</li><li>当 C 函数通过 <code>*output1 = out_val;</code> 修改了 <code>output1</code> 指向的值，<code>temp</code> 的值也随之改变。</li></ul></li><li><p><strong>编译器的角色：</strong></p><ul><li>SystemVerilog 编译器负责参数传递的处理，对于 <code>output</code> 和 <code>inout</code> 参数，会自动传递变量的地址（指针）。</li><li>这使得在 Verilog 代码中调用函数时，<strong>无需显式地取地址</strong>，代码更简洁。</li></ul></li></ol><hr><p><strong>总结：</strong></p><ul><li><p><strong>按值传递 vs 按引用传递：</strong></p><ul><li><strong>按值传递（Value）：</strong> 仅传递变量的副本，函数内部的修改不会影响原变量。</li><li><strong>按引用传递（Reference）：</strong> 传递变量的地址，函数内部的修改会影响原变量。</li></ul></li><li><p><strong>在 DPI-C 中，<code>output</code> 参数被按引用传递，即使在 Verilog 中看起来像是按值传递。</strong></p></li><li><p><strong>因此，C 函数可以通过指针修改 Verilog 中的变量。</strong></p></li></ul><hr><p><strong>示例对照：</strong></p><ul><li><p><strong>Verilog 调用：</strong></p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">int</span> temp;<br>call_c_function(input1, temp); <span class="hljs-comment">// temp 被作为 output 参数，按引用传递</span><br></code></pre></td></tr></table></figure></li><li><p><strong>C 函数接收：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">call_c_function</span><span class="hljs-params">(<span class="hljs-type">uint32_t</span> input1, <span class="hljs-type">uint32_t</span>* output1)</span> </span>&#123;<br>    <span class="hljs-comment">// output1 是一个指向 temp 的指针</span><br>&#125;<br></code></pre></td></tr></table></figure></li><li><p><strong>C 函数内部修改：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp">*output1 = input1 + <span class="hljs-number">1</span>; <span class="hljs-comment">// 修改了 temp 的值</span><br></code></pre></td></tr></table></figure></li><li><p><strong>Verilog 中的结果：</strong></p><ul><li>调用结束后，<code>temp</code> 的值被更新为 <code>input1 + 1</code>。</li></ul></li></ul><hr><p><strong>进一步说明：</strong></p><ul><li><p><strong>为什么不需要在 Verilog 中取地址？</strong></p><ul><li>在高级语言中，如 C 或 C++，当需要传递变量的地址时，需要显式地使用取地址符 <code>&amp;</code>。</li><li>但在 Verilog 中，参数传递方式由参数方向决定，编译器自动处理，无需显式取地址。</li><li>这使得代码更简洁，同时避免了与硬件描述语言的风格冲突。</li></ul></li><li><p><strong>如何确认参数传递方式？</strong></p><ul><li>查看函数的声明，关注参数的方向（<code>input</code>、<code>output</code>）。</li><li>在 C 函数中，<code>input</code> 参数对应于值，<code>output</code> 参数对应于指针。</li></ul></li></ul><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;span id=&quot;more&quot;&gt;&lt;/span&gt;

&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;DPI-C 是 Verilator 提供的一种机制，可以在 Verilog 代码中调用 C</summary>
      
    
    
    
    <category term="PA2" scheme="http://blog.luliang.online/categories/PA2/"/>
    
    <category term="模拟器" scheme="http://blog.luliang.online/categories/PA2/%E6%A8%A1%E6%8B%9F%E5%99%A8/"/>
    
    
    <category term="DPI-C" scheme="http://blog.luliang.online/tags/DPI-C/"/>
    
    <category term="Verilog" scheme="http://blog.luliang.online/tags/Verilog/"/>
    
  </entry>
  
  <entry>
    <title>verilator 编译多个 cpp 文件</title>
    <link href="http://blog.luliang.online/2024/09/25/verilator%E7%BC%96%E8%AF%91%E5%A4%9A%E4%B8%AAcpp%E6%96%87%E4%BB%B6/"/>
    <id>http://blog.luliang.online/2024/09/25/verilator%E7%BC%96%E8%AF%91%E5%A4%9A%E4%B8%AAcpp%E6%96%87%E4%BB%B6/</id>
    <published>2024-09-25T10:20:40.000Z</published>
    <updated>2025-02-18T13:55:24.283Z</updated>
    
    <content type="html"><![CDATA[<span id="more"></span><h2 id="目录结构"><a href="#目录结构" class="headerlink" title="目录结构"></a>目录结构</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs dir">verilator_helpers/<br>│   └── include/<br>│       └── helpers.h<br>│   └── src/<br>│       └── helpers.cpp<br>│<br>verilatorTest/<br>├── Makefile<br>├── top.v<br>└── main.cpp<br></code></pre></td></tr></table></figure><h2 id="实验"><a href="#实验" class="headerlink" title="实验"></a>实验</h2><p>在这个实践中，用 verilator 编译了多个文件：<code>helpers.cpp</code> <code>main.cpp</code>。</p><p>这是一个设想，没想到它是可以的，只要加一些简单的参数就好了：</p><p>main.cpp:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// main.cpp</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;Vtop.h&gt;</span>           <span class="hljs-comment">// 生成的顶层模块头文件</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;verilated.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;helpers.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">helpers</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-built_in">help1</span>();<br>    <span class="hljs-built_in">help2</span>();<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> **argv)</span> </span>&#123;<br>    <span class="hljs-built_in">helpers</span>();<br>    Verilated::<span class="hljs-built_in">commandArgs</span>(argc, argv);<br>    Vtop *top = <span class="hljs-keyword">new</span> Vtop;<br><br>    <span class="hljs-comment">// 初始化信号</span><br>    top-&gt;clk = <span class="hljs-number">0</span>;<br>    top-&gt;rst = <span class="hljs-number">1</span>;<br><br>    <span class="hljs-comment">// 仿真循环</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">20</span>; i++) &#123;<br>        top-&gt;clk = !top-&gt;clk;<br>        <span class="hljs-keyword">if</span> (i == <span class="hljs-number">2</span>)<br>            top-&gt;rst = <span class="hljs-number">0</span>;<br>        top-&gt;<span class="hljs-built_in">eval</span>();<br>        <span class="hljs-comment">// 输出结果</span><br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Cycle %d: counter = %d\n&quot;</span>, i, top-&gt;counter);<br>    &#125;<br><br>    <span class="hljs-keyword">delete</span> top;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>helpers.cpp:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;helpers.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">help1</span><span class="hljs-params">()</span> </span>&#123;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;help1()&quot;</span> &lt;&lt; std::endl;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">help2</span><span class="hljs-params">()</span> </span>&#123;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;help2()&quot;</span> &lt;&lt; std::endl;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>helpers.h:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> _HELPERS_H_</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> _HELPERS_H_</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">help1</span><span class="hljs-params">()</span></span>;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">help2</span><span class="hljs-params">()</span></span>;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br></code></pre></td></tr></table></figure><p>Makefile:</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs Makefile"><span class="hljs-section">hdl:</span><br>verilator --cc top.v --exe main.cpp /home/luyoung/Test/verilator_helpers/src/helpers.cpp --CFLAGS <span class="hljs-string">&quot;-I/home/luyoung/Test/verilator_helpers/include&quot;</span><br><br><span class="hljs-section">build:</span><br>bear -- make -C obj_dir -f Vtop.mk<br><br><span class="hljs-section">run:</span><br>./obj_dir/Vtop<br><br><span class="hljs-section">clean:</span><br>rm -rf ./obj_dir<br><br></code></pre></td></tr></table></figure><p>从这个 <code>Makefile</code> 中可以看到，我们只需要在 <code>verilator</code> 后面加上其它源文件的路径，然后通过 <code>--CFLAGS</code> 再加上头文件的搜索路径，就可以一起生成 <code>Vtop.mk</code>:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ <span class="hljs-built_in">cat</span> Vtop.mk<br><span class="hljs-comment"># Verilated -*- Makefile -*-</span><br><span class="hljs-comment"># DESCRIPTION: Verilator output: Makefile for building Verilated archive or executable</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># Execute this makefile from the object directory:</span><br><span class="hljs-comment">#    make -f Vtop.mk</span><br><br>default: Vtop<br><br><span class="hljs-comment">### Constants...</span><br><span class="hljs-comment"># Perl executable (from $PERL)</span><br>PERL = perl<br><span class="hljs-comment"># Path to Verilator kit (from $VERILATOR_ROOT)</span><br>VERILATOR_ROOT = /usr/local/share/verilator<br><span class="hljs-comment"># SystemC include directory with systemc.h (from $SYSTEMC_INCLUDE)</span><br>SYSTEMC_INCLUDE ?=<br><span class="hljs-comment"># SystemC library directory with libsystemc.a (from $SYSTEMC_LIBDIR)</span><br>SYSTEMC_LIBDIR ?=<br><br><span class="hljs-comment">### Switches...</span><br><span class="hljs-comment"># C++ code coverage  0/1 (from --prof-c)</span><br>VM_PROFC = 0<br><span class="hljs-comment"># SystemC output mode?  0/1 (from --sc)</span><br>VM_SC = 0<br><span class="hljs-comment"># Legacy or SystemC output mode?  0/1 (from --sc)</span><br>VM_SP_OR_SC = $(VM_SC)<br><span class="hljs-comment"># Deprecated</span><br>VM_PCLI = 1<br><span class="hljs-comment"># Deprecated: SystemC architecture to find link library path (from $SYSTEMC_ARCH)</span><br>VM_SC_TARGET_ARCH = linux<br><br><span class="hljs-comment">### Vars...</span><br><span class="hljs-comment"># Design prefix (from --prefix)</span><br>VM_PREFIX = Vtop<br><span class="hljs-comment"># Module prefix (from --prefix)</span><br>VM_MODPREFIX = Vtop<br><span class="hljs-comment"># User CFLAGS (from -CFLAGS on Verilator command line)</span><br>VM_USER_CFLAGS = \<br>        -I/home/luyoung/Test/verilator_helpers/include \<br><br><span class="hljs-comment"># User LDLIBS (from -LDFLAGS on Verilator command line)</span><br>VM_USER_LDLIBS = \<br><br><span class="hljs-comment"># User .cpp files (from .cpp&#x27;s on Verilator command line)</span><br>VM_USER_CLASSES = \<br>        helpers \<br>        main \<br><br><span class="hljs-comment"># User .cpp directories (from .cpp&#x27;s on Verilator command line)</span><br>VM_USER_DIR = \<br>        . \<br>        /home/luyoung/Test/verilator_helpers/src \<br><br><br><span class="hljs-comment">### Default rules...</span><br><span class="hljs-comment"># Include list of all generated classes</span><br>include Vtop_classes.mk<br><span class="hljs-comment"># Include global rules</span><br>include $(VERILATOR_ROOT)/include/verilated.mk<br><br><span class="hljs-comment">### Executable rules... (from --exe)</span><br>VPATH += $(VM_USER_DIR)<br><br>helpers.o: /home/luyoung/Test/verilator_helpers/src/helpers.cpp<br>        $(OBJCACHE) $(CXX) $(CXXFLAGS) $(CPPFLAGS) $(OPT_FAST) -c -o <span class="hljs-variable">$@</span> $&lt;<br>main.o: main.cpp<br>        $(OBJCACHE) $(CXX) $(CXXFLAGS) $(CPPFLAGS) $(OPT_FAST) -c -o <span class="hljs-variable">$@</span> $&lt;<br><br><span class="hljs-comment">### Link rules... (from --exe)</span><br>Vtop: $(VK_USER_OBJS) $(VK_GLOBAL_OBJS) $(VM_PREFIX)__ALL.a $(VM_HIER_LIBS)<br>        $(LINK) $(LDFLAGS) $^ $(LOADLIBES) $(LDLIBS) $(LIBS) $(SC_LIBS) -o <span class="hljs-variable">$@</span><br><br><br><span class="hljs-comment"># Verilated -*- Makefile -*-</span><br></code></pre></td></tr></table></figure><p>可以看到，确实如此。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;span id=&quot;more&quot;&gt;&lt;/span&gt;


&lt;h2 id=&quot;目录结构&quot;&gt;&lt;a href=&quot;#目录结构&quot; class=&quot;headerlink&quot; title=&quot;目录结构&quot;&gt;&lt;/a&gt;目录结构&lt;/h2&gt;&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;ta</summary>
      
    
    
    
    <category term="PA2" scheme="http://blog.luliang.online/categories/PA2/"/>
    
    <category term="模拟器" scheme="http://blog.luliang.online/categories/PA2/%E6%A8%A1%E6%8B%9F%E5%99%A8/"/>
    
    
    <category term="verilator" scheme="http://blog.luliang.online/tags/verilator/"/>
    
    <category term="编译" scheme="http://blog.luliang.online/tags/%E7%BC%96%E8%AF%91/"/>
    
  </entry>
  
  <entry>
    <title>Chisel 中的 BlackBox 机制</title>
    <link href="http://blog.luliang.online/2024/09/24/Chisel_BlackBox/"/>
    <id>http://blog.luliang.online/2024/09/24/Chisel_BlackBox/</id>
    <published>2024-09-24T10:20:40.000Z</published>
    <updated>2025-02-18T13:55:24.273Z</updated>
    
    <content type="html"><![CDATA[<span id="more"></span><h3 id="什么是-Chisel-中的-BlackBox？"><a href="#什么是-Chisel-中的-BlackBox？" class="headerlink" title="什么是 Chisel 中的 BlackBox？"></a>什么是 Chisel 中的 BlackBox？</h3><p>在硬件设计中，<strong>BlackBox</strong> 是一种用于集成外部硬件模块的方法。在 Chisel 中，BlackBox 允许设计者将已经存在的硬件描述（如 Verilog 或 SystemVerilog 编写的模块）引入到 Chisel 项目中，而无需用 Chisel 重新实现这些模块。这种方法特别适用于以下情况：</p><ol><li><strong>重用现有模块</strong>：你可能已经有一些经过验证的 Verilog&#x2F;SystemVerilog 模块，希望在新的 Chisel 项目中重用它们。</li><li><strong>使用第三方 IP 核</strong>：许多硬件设计中会使用第三方提供的知识产权（IP）核，如处理器核心、存储控制器等。</li><li><strong>集成特定功能</strong>：某些功能可能需要用特定语言或工具实现，BlackBox 提供了一个桥梁，将这些功能集成到 Chisel 项目中。</li></ol><h3 id="为什么使用-BlackBox？"><a href="#为什么使用-BlackBox？" class="headerlink" title="为什么使用 BlackBox？"></a>为什么使用 BlackBox？</h3><p>Chisel 是一个基于 Scala 的硬件描述语言，它提供了强大的抽象能力和灵活性。然而，在某些情况下，使用 Chisel 重新实现所有模块可能既费时又不实际。BlackBox 允许你在 Chisel 项目中无缝集成其他语言（如 Verilog&#x2F;SystemVerilog）编写的模块，从而结合了 Chisel 的高层次抽象和传统硬件描述语言的广泛支持。</p><h3 id="如何在-Chisel-中使用-BlackBox？"><a href="#如何在-Chisel-中使用-BlackBox？" class="headerlink" title="如何在 Chisel 中使用 BlackBox？"></a>如何在 Chisel 中使用 BlackBox？</h3><p>以下是使用 BlackBox 的基本步骤：</p><ol><li><strong>定义 BlackBox 类</strong>：在 Chisel 中创建一个继承自 <code>BlackBox</code> 的类，定义其输入和输出端口。</li><li><strong>实例化 BlackBox</strong>：在你的 Chisel 模块中实例化 BlackBox 并连接相应的信号。</li><li><strong>生成 Verilog</strong>：使用 Chisel 的工具生成最终的 Verilog 文件，确保外部模块被正确引用。</li></ol><h3 id="详细步骤解析"><a href="#详细步骤解析" class="headerlink" title="详细步骤解析"></a>详细步骤解析</h3><h4 id="0-定义-BlackBox"><a href="#0-定义-BlackBox" class="headerlink" title="0. 定义 BlackBox"></a>0. 定义 BlackBox</h4><p>这里需要注意的是，这个黑盒子使用 Verilog 实现的，它 将会在里面做一些 Chisel 做不到的事情，比如DPI-C 机制。因此我们要利用这个黑科技，让它在 Chisel 中发挥作用。</p><p>假设我们的黑盒子长这个样子（<code>./aaa/MyBlackBox.sv</code>）：</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs Verilog"><span class="hljs-keyword">module</span> MyBlackBox(<br>    <span class="hljs-keyword">input</span>  <span class="hljs-keyword">logic</span>        clock,<br>    <span class="hljs-keyword">input</span>  <span class="hljs-keyword">logic</span>        reset,<br>    <span class="hljs-keyword">input</span>  <span class="hljs-keyword">logic</span> [<span class="hljs-number">31</span>:<span class="hljs-number">0</span>] input1,<br>    <span class="hljs-keyword">output</span> <span class="hljs-keyword">logic</span> [<span class="hljs-number">31</span>:<span class="hljs-number">0</span>] output1<br>);<br>    <span class="hljs-keyword">import</span> <span class="hljs-string">&quot;DPI-C&quot;</span> <span class="hljs-keyword">function</span> <span class="hljs-keyword">void</span> call_c_function(<br>        <span class="hljs-keyword">input</span>  <span class="hljs-keyword">logic</span> [<span class="hljs-number">31</span>:<span class="hljs-number">0</span>] input1,<br>        <span class="hljs-keyword">output</span> <span class="hljs-keyword">logic</span> [<span class="hljs-number">31</span>:<span class="hljs-number">0</span>] output1<br>    );<br><br>    <span class="hljs-keyword">logic</span> [<span class="hljs-number">31</span>:<span class="hljs-number">0</span>] temp_output1;<br><br>    <span class="hljs-keyword">always_ff</span> @(<span class="hljs-keyword">posedge</span> clock <span class="hljs-keyword">or</span> <span class="hljs-keyword">posedge</span> reset) <span class="hljs-keyword">begin</span><br>        <span class="hljs-keyword">if</span> (reset) <span class="hljs-keyword">begin</span><br>            output1 &lt;= <span class="hljs-number">32&#x27;b0</span>;<br>        <span class="hljs-keyword">end</span> <span class="hljs-keyword">else</span> <span class="hljs-keyword">begin</span><br>            call_c_function(input1, temp_output1);<br>            output1 &lt;= temp_output1;<br>        <span class="hljs-keyword">end</span><br>    <span class="hljs-keyword">end</span><br><span class="hljs-keyword">endmodule</span><br><br><br></code></pre></td></tr></table></figure><p>这样黑盒子就定义完成了，接下来就是把它接入到 Chisel 中。</p><h4 id="1-定义-BlackBox-类（包装器）-MyBlackBox-scala"><a href="#1-定义-BlackBox-类（包装器）-MyBlackBox-scala" class="headerlink" title="1. 定义 BlackBox 类（包装器） (./MyBlackBox.scala)"></a>1. 定义 BlackBox 类（包装器） (<code>./MyBlackBox.scala</code>)</h4><p>这个类是用来包装黑盒子的，给它包装一下，这样就能在 Chisel 中使用了。注意包装的时候，一定要将这里的引脚名字、类型、数量等严格与被包装的黑盒子相同，不然会在编译（verilater）的时候报错。比如你不能在黑盒子中定义<code>input1</code>，又在包装器（Wrapper）中定义<code>input2</code>。</p><p>这里再插一嘴，这里的这个<code>包装器</code>（我起的名字）是一个特殊的类，它扩展于 BlackBox，因此它不需要连线就可以编译到 <code>hdl</code> 成功。</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs scala"><span class="hljs-keyword">import</span> chisel3._<br><span class="hljs-keyword">import</span> chisel3.util._<br><span class="hljs-keyword">import</span> chisel3.experimental._<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyBlackBox</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">BlackBox</span> <span class="hljs-keyword">with</span> <span class="hljs-title">HasBlackBoxPath</span> </span>&#123;<br>  <span class="hljs-keyword">val</span> io = <span class="hljs-type">IO</span>(<span class="hljs-keyword">new</span> <span class="hljs-type">Bundle</span> &#123;<br>    <span class="hljs-keyword">val</span> clock = <span class="hljs-type">Input</span>(<span class="hljs-type">Clock</span>())<br>    <span class="hljs-keyword">val</span> reset = <span class="hljs-type">Input</span>(<span class="hljs-type">Bool</span>())<br>    <span class="hljs-keyword">val</span> input1 = <span class="hljs-type">Input</span>(<span class="hljs-type">UInt</span>(<span class="hljs-number">32.</span><span class="hljs-type">W</span>))<br>    <span class="hljs-keyword">val</span> output1 = <span class="hljs-type">Output</span>(<span class="hljs-type">UInt</span>(<span class="hljs-number">32.</span><span class="hljs-type">W</span>))<br>  &#125;)<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>**<code>extends BlackBox</code>**：这表示 <code>MyBlackBox</code> 是一个黑盒模块，不在 Chisel 代码中实现其具体逻辑。</li><li>**<code>with HasBlackBoxPath</code>**：这允许你指定 BlackBox 的文件路径，Chisel 在生成 Verilog 时会知道去哪里找到相应的外部模块。</li><li>**<code>val io = IO(new Bundle &#123; ... &#125;)</code>**：定义了 BlackBox 的输入和输出端口，这些端口需要与外部模块（如 <code>MyBlackBox.sv</code>）的端口相匹配。</li></ul><h4 id="2-实例化-BlackBox-MyModule-scala"><a href="#2-实例化-BlackBox-MyModule-scala" class="headerlink" title="2. 实例化 BlackBox (./MyModule.scala)"></a>2. 实例化 BlackBox (<code>./MyModule.scala</code>)</h4><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs scala"><span class="hljs-keyword">import</span> chisel3._<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyModule</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Module</span> </span>&#123;<br>  <span class="hljs-keyword">val</span> io = <span class="hljs-type">IO</span>(<span class="hljs-keyword">new</span> <span class="hljs-type">Bundle</span> &#123;<br>    <span class="hljs-keyword">val</span> in = <span class="hljs-type">Input</span>(<span class="hljs-type">UInt</span>(<span class="hljs-number">32.</span><span class="hljs-type">W</span>))<br>    <span class="hljs-keyword">val</span> out = <span class="hljs-type">Output</span>(<span class="hljs-type">UInt</span>(<span class="hljs-number">32.</span><span class="hljs-type">W</span>))<br>  &#125;)<br><br>  <span class="hljs-comment">// 实例化 BlackBox</span><br>  <span class="hljs-keyword">val</span> blackBox = <span class="hljs-type">Module</span>(<span class="hljs-keyword">new</span> <span class="hljs-type">MyBlackBox</span>)<br><br>  <span class="hljs-comment">// 连接信号</span><br>  blackBox.io.clock := clock<br>  blackBox.io.reset := reset<br>  blackBox.io.input1 := io.in<br>  io.out := blackBox.io.output1<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">object</span> <span class="hljs-title">MyModule</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">App</span> </span>&#123;<br>  (<span class="hljs-keyword">new</span> chisel3.stage.<span class="hljs-type">ChiselStage</span>).emitVerilog(<span class="hljs-keyword">new</span> <span class="hljs-type">MyModule</span>)<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><strong>实例化 BlackBox</strong>：使用 <code>Module(new MyBlackBox)</code> 创建一个 BlackBox 实例。</li><li><strong>连接信号</strong>：将 Chisel 模块的信号连接到 BlackBox 的端口。例如，将顶层模块的 <code>io.in</code> 连接到 BlackBox 的 <code>input1</code>，并将 BlackBox 的 <code>output1</code> 连接到顶层模块的 <code>io.out</code>。</li></ul><h4 id="3-生成-Verilog-MyModule-对象"><a href="#3-生成-Verilog-MyModule-对象" class="headerlink" title="3. 生成 Verilog (MyModule 对象)"></a>3. 生成 Verilog (<code>MyModule</code> 对象)</h4><p>运行 <code>MyModule</code> 对象的 <code>App</code> 将使用 Chisel 的 <code>ChiselStage</code> 生成最终的 Verilog 文件。生成的 Verilog 文件将包含对 <code>MyBlackBox.sv</code> 的引用，确保在综合和仿真时能够正确找到并使用外部模块。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">sbt run<br></code></pre></td></tr></table></figure><p>运行上述命令后，Chisel 会生成包含 <code>MyModule</code> 的 Verilog 文件，通常命名为 <code>MyModule.v</code>。确保在综合工具或仿真环境中将 <code>MyBlackBox.sv</code> 文件包含进去，以便正确解析 BlackBox 模块。</p><h4 id="4-编译-main-cpp"><a href="#4-编译-main-cpp" class="headerlink" title="4. 编译(./main.cpp)"></a>4. 编译(<code>./main.cpp</code>)</h4><p>main.cpp:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs Cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdint.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;VMyModule.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;verilated.h&quot;</span></span><br><br><span class="hljs-keyword">extern</span> <span class="hljs-string">&quot;C&quot;</span> <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">call_c_function</span><span class="hljs-params">(<span class="hljs-type">uint32_t</span> input1, <span class="hljs-type">uint32_t</span>* output1)</span> </span>&#123;<br>    <span class="hljs-type">uint32_t</span> in_val = input1;<br>    <span class="hljs-type">uint32_t</span> out_val = in_val + <span class="hljs-number">1</span>; <span class="hljs-comment">// 示例处理</span><br>    *output1 = out_val;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;hello, this is a test func.\n&quot;</span>);<br>&#125;<br><br><span class="hljs-type">static</span> VMyModule* top = <span class="hljs-literal">NULL</span>;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">step</span><span class="hljs-params">()</span> </span>&#123;<br>    top-&gt;clock = <span class="hljs-number">0</span>;<br>    top-&gt;<span class="hljs-built_in">eval</span>();<br>    top-&gt;clock = <span class="hljs-number">1</span>;<br>    top-&gt;<span class="hljs-built_in">eval</span>();<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">reset</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>&#123;<br>    top-&gt;reset = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span> (n--) &#123;<br>        <span class="hljs-built_in">step</span>();<br>    &#125;<br>    top-&gt;reset = <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span>* argv[])</span> </span>&#123;<br>    Verilated::<span class="hljs-built_in">commandArgs</span>(argc, argv);<br>    top = <span class="hljs-keyword">new</span> VMyModule;<br><br>    <span class="hljs-built_in">reset</span>(<span class="hljs-number">1</span>);  <span class="hljs-comment">// 初始化</span><br><br>    <span class="hljs-comment">// 设置输入信号</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; ++i) &#123;<br>        top-&gt;io_in = <span class="hljs-built_in">uint32_t</span>(i); <span class="hljs-comment">// 更新输入信号</span><br>        <span class="hljs-built_in">step</span>(); <span class="hljs-comment">// 进行一步仿真</span><br><br>        <span class="hljs-comment">// 打印输出结果</span><br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Input: %u, Output: %d\n&quot;</span>, top-&gt;io_in, top-&gt;io_out); <span class="hljs-comment">// 这里其实在打印地址</span><br>    &#125;<br><br>    <span class="hljs-keyword">delete</span> top; <span class="hljs-comment">// 释放资源</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>此时就可以编译了，但是编译要注意使用<code>-I</code> 将黑盒子连接起来，这里就不使用在包装器中重定路径的方法了，不能用，不知道为什么。</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs Makefile"><br><span class="hljs-section">hdl:</span><br>@sbt clean<br>@sbt run<br><br><span class="hljs-section">build:</span><br>bear -- verilator --cc MyModule.v --exe --build main.cpp -I/home/luyoung/Test/BlackBox/aaa<br><br><span class="hljs-section">clean:</span><br>@rm -rf obj_dir project target<br><br><span class="hljs-section">run:</span><br>./obj_dir/VMyModule<br><br><span class="hljs-meta"><span class="hljs-keyword">.PHONY</span>: hdl build clean</span><br><br><br></code></pre></td></tr></table></figure><p>直接生成 hdl、编译、运行，就好了。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs bash">make hdl<br>make build<br>make run<br><br>hello, this is a <span class="hljs-built_in">test</span> func.<br>Input: 0, Output: -609878311<br>hello, this is a <span class="hljs-built_in">test</span> func.<br>Input: 1, Output: -609878311<br>hello, this is a <span class="hljs-built_in">test</span> func.<br>Input: 2, Output: -609878311<br>hello, this is a <span class="hljs-built_in">test</span> func.<br>Input: 3, Output: -609878311<br>hello, this is a <span class="hljs-built_in">test</span> func.<br>Input: 4, Output: -609878311<br>hello, this is a <span class="hljs-built_in">test</span> func.<br>Input: 5, Output: -609878311<br>hello, this is a <span class="hljs-built_in">test</span> func.<br>Input: 6, Output: -609878311<br>hello, this is a <span class="hljs-built_in">test</span> func.<br>Input: 7, Output: -609878311<br>hello, this is a <span class="hljs-built_in">test</span> func.<br>Input: 8, Output: -609878311<br>hello, this is a <span class="hljs-built_in">test</span> func.<br>Input: 9, Output: -609878311<br><br></code></pre></td></tr></table></figure><h3 id="BlackBox-的使用场景"><a href="#BlackBox-的使用场景" class="headerlink" title="BlackBox 的使用场景"></a>BlackBox 的使用场景</h3><ol><li><strong>集成现有模块</strong>：例如，你有一个经过验证的加密模块或通信接口模块，直接在 Chisel 项目中复用它们。</li><li><strong>混合语言设计</strong>：某些模块可能用不同的语言编写，如 Verilog、SystemVerilog 或 VHDL，BlackBox 允许这些模块与 Chisel 代码协同工作。</li><li><strong>第三方 IP 核</strong>：许多芯片设计中使用第三方提供的 IP 核（如存储控制器、处理器核心），通过 BlackBox 可以轻松集成这些 IP 核。</li><li><strong>特定功能实现</strong>：某些功能可能需要用特定的工具或库实现，BlackBox 提供了一个桥梁，将这些功能集成到 Chisel 设计中。</li></ol><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>以上是一个包装器包装黑盒子的最佳实践，也算是 BlackBox 的入门。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;span id=&quot;more&quot;&gt;&lt;/span&gt;

&lt;h3 id=&quot;什么是-Chisel-中的-BlackBox？&quot;&gt;&lt;a href=&quot;#什么是-Chisel-中的-BlackBox？&quot; class=&quot;headerlink&quot; title=&quot;什么是 Chisel 中的 BlackBo</summary>
      
    
    
    
    <category term="PA2" scheme="http://blog.luliang.online/categories/PA2/"/>
    
    <category term="模拟器" scheme="http://blog.luliang.online/categories/PA2/%E6%A8%A1%E6%8B%9F%E5%99%A8/"/>
    
    
    <category term="Chisel" scheme="http://blog.luliang.online/tags/Chisel/"/>
    
    <category term="DPI-C" scheme="http://blog.luliang.online/tags/DPI-C/"/>
    
  </entry>
  
  <entry>
    <title>YPC的研究</title>
    <link href="http://blog.luliang.online/2024/09/20/YPC%E7%9A%84%E7%A0%94%E7%A9%B6/"/>
    <id>http://blog.luliang.online/2024/09/20/YPC%E7%9A%84%E7%A0%94%E7%A9%B6/</id>
    <published>2024-09-20T10:20:40.000Z</published>
    <updated>2025-02-18T13:55:24.280Z</updated>
    
    <content type="html"><![CDATA[<span id="more"></span><h2 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h2><p>本文尝试去分析 YSYX 中的一个实例 <a href="https://ysyx.oscc.cc/slides/2306/06.html#/%E7%94%A8%E7%BB%84%E5%90%88%E9%80%BB%E8%BE%91%E7%94%B5%E8%B7%AF%E5%AE%9E%E7%8E%B0%E6%8C%87%E4%BB%A4%E7%9A%84%E8%AF%AD%E4%B9%89">YPC</a>,YPC 使用 Chisel 来实现基本的指令执行过程：定义指令结构、取指、解码（操作码、操作数）、执行、更新 PC。</p><h2 id="二、写被执行的程序"><a href="#二、写被执行的程序" class="headerlink" title="二、写被执行的程序"></a>二、写被执行的程序</h2><p>这个程序主要使用内嵌汇编的方法来执行一些汇编代码，我们可以确认它仅仅包含这些指令，应为 <code>YPC</code> 被设计为只能执行 <code>I类指令</code>的两种指令，<code>addi</code> 和 <code>ebreak</code>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">ebreak</span><span class="hljs-params">(<span class="hljs-type">long</span> arg0, <span class="hljs-type">long</span> arg1)</span> &#123;<br>  <span class="hljs-keyword">asm</span> <span class="hljs-title function_">volatile</span><span class="hljs-params">(<span class="hljs-string">&quot;addi a0, x0, %0;&quot;</span></span><br><span class="hljs-params">               <span class="hljs-string">&quot;addi a1, x0, %1;&quot;</span></span><br><span class="hljs-params">               <span class="hljs-string">&quot;ebreak&quot;</span> : : <span class="hljs-string">&quot;i&quot;</span>(arg0), <span class="hljs-string">&quot;i&quot;</span>(arg1))</span>;<br>&#125;<br><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">putch</span><span class="hljs-params">(<span class="hljs-type">char</span> ch)</span> &#123; ebreak(<span class="hljs-number">0</span>, ch); &#125;<br><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">halt</span><span class="hljs-params">(<span class="hljs-type">int</span> code)</span> &#123; ebreak(<span class="hljs-number">1</span>, code); <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>); &#125;<br><br><span class="hljs-type">void</span> _start() &#123;<br>  putch(<span class="hljs-string">&#x27;H&#x27;</span>); putch(<span class="hljs-string">&#x27;e&#x27;</span>); putch(<span class="hljs-string">&#x27;l&#x27;</span>); putch(<span class="hljs-string">&#x27;l&#x27;</span>); putch(<span class="hljs-string">&#x27;o&#x27;</span>); putch(<span class="hljs-string">&#x27;,&#x27;</span>); putch(<span class="hljs-string">&#x27; &#x27;</span>);<br>  putch(<span class="hljs-string">&#x27;R&#x27;</span>); putch(<span class="hljs-string">&#x27;I&#x27;</span>); putch(<span class="hljs-string">&#x27;S&#x27;</span>); putch(<span class="hljs-string">&#x27;C&#x27;</span>); putch(<span class="hljs-string">&#x27;-&#x27;</span>); putch(<span class="hljs-string">&#x27;V&#x27;</span>); putch(<span class="hljs-string">&#x27;!&#x27;</span>);<br>  putch(<span class="hljs-string">&#x27;\n&#x27;</span>);<br>  halt(<span class="hljs-number">0</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>这个程序很简单，不管是 <code>putch</code> 还是 <code>halt</code>，它都会自己调用函数 <code>ebreak()</code>，其对应着 3 条指令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs asm">addi a0, x0, %0<br>addi a1, x0, %1<br>ebreak : : &quot;i&quot;(arg0), &quot;i&quot;(arg1) ; arg0 传给寄存器 a0(10号寄存器)，arg1 传给寄存器a1(11号寄存器)<br></code></pre></td></tr></table></figure><p>这里需要澄清的是，这是一个程序，它会在riscv 上自己执行， 它不会做额外的事情。</p><p>我们可以把这个程序编译一下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><code class="hljs bash">rv32gcc -ffreestanding -nostdlib -static -Wl,-Ttext=0 -O2 -o prog a.c<br>rvobjdump -M no-aliases -d prog <span class="hljs-comment"># 查看反汇编</span><br><br>prog:     file format elf32-littleriscv<br><br><br>Disassembly of section .text:<br><br>00000000 &lt;_start&gt;:<br>   0:   00000513                addi    a0,zero,0<br>   4:   04800593                addi    a1,zero,72<br>   8:   00100073                ebreak<br>   c:   00000513                addi    a0,zero,0<br>  10:   06500593                addi    a1,zero,101<br>  14:   00100073                ebreak<br>  18:   00000513                addi    a0,zero,0<br>  1c:   06c00593                addi    a1,zero,108<br>  20:   00100073                ebreak<br>  24:   00000513                addi    a0,zero,0<br>  28:   06c00593                addi    a1,zero,108<br>  2c:   00100073                ebreak<br>  30:   00000513                addi    a0,zero,0<br>  34:   06f00593                addi    a1,zero,111<br>  38:   00100073                ebreak<br>  3c:   00000513                addi    a0,zero,0<br>  40:   02c00593                addi    a1,zero,44<br>  44:   00100073                ebreak<br>  48:   00000513                addi    a0,zero,0<br>  4c:   02000593                addi    a1,zero,32<br>  50:   00100073                ebreak<br>  54:   00000513                addi    a0,zero,0<br>  58:   05200593                addi    a1,zero,82<br>  5c:   00100073                ebreak<br>  60:   00000513                addi    a0,zero,0<br>  64:   04900593                addi    a1,zero,73<br>  68:   00100073                ebreak<br>  6c:   00000513                addi    a0,zero,0<br>  70:   05300593                addi    a1,zero,83<br>  74:   00100073                ebreak<br>  78:   00000513                addi    a0,zero,0<br>  7c:   04300593                addi    a1,zero,67<br>  80:   00100073                ebreak<br>  84:   00000513                addi    a0,zero,0<br>  88:   02d00593                addi    a1,zero,45<br>  8c:   00100073                ebreak<br>  90:   00000513                addi    a0,zero,0<br>  94:   05600593                addi    a1,zero,86<br>  98:   00100073                ebreak<br>  9c:   00000513                addi    a0,zero,0<br>  a0:   02100593                addi    a1,zero,33<br>  a4:   00100073                ebreak<br>  a8:   00000513                addi    a0,zero,0<br>  ac:   00a00593                addi    a1,zero,10<br>  b0:   00100073                ebreak<br>  b4:   00100513                addi    a0,zero,1<br>  b8:   00000593                addi    a1,zero,0<br>  bc:   00100073                ebreak<br>  c0:   0000006f                jal     zero,c0 &lt;_start+0xc0&gt;<br><br><br></code></pre></td></tr></table></figure><p>可以看到这个程序真的只含有两条指令（最后一条 jal 指令是跳转指令，目的是制造死循环，不用管）。</p><p>但是我们可以手动写一个解释器，它可以用来<code>执行</code> riscv 代码，甚至我们可以根据 ebreak 的参数来确定接下来的行为。比如，当调用函数 <code>ebreak( 0,ch)</code>的时候，这时候 a0 就是 0，a11 就是 ch，我们可以定义它为输出字符；当调用函数 <code>ebreak( 1,code)</code>的时候，这时候 a0 就是 1，a11 就是 code，我们甚至可以根据不同的 code 来触发不同的行为。</p><p>由于我只需要二进制程序 prog 中的汇编指令，因此我们可以利用命令将一个可执行二进制文件中的汇编指令抽离出来：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">riscv64-linux-gnu-objcopy -j .text -O binary prog prog.bin<br></code></pre></td></tr></table></figure><p>这样里面就仅仅包含了我们想要的二进制指令，然后就可以放在解释器上执行它了。</p><p>在 PYC 中，我们定义了两种有限的行为：</p><ul><li>打印 ch</li><li>停机</li></ul><h2 id="YPC"><a href="#YPC" class="headerlink" title="YPC"></a>YPC</h2><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs Scala"><span class="hljs-keyword">import</span> chisel3._<br><span class="hljs-keyword">import</span> chisel3.util._<br><span class="hljs-keyword">import</span> chisel3.util.experimental.loadMemoryFromFileInline<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">YPC</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Module</span> </span>&#123;<br>  <span class="hljs-keyword">val</span> io = <span class="hljs-type">IO</span>(<span class="hljs-keyword">new</span> <span class="hljs-type">Bundle</span> &#123; <span class="hljs-keyword">val</span> halt = <span class="hljs-type">Output</span>(<span class="hljs-type">Bool</span>()) &#125;)<br>  <span class="hljs-keyword">val</span> <span class="hljs-type">R</span> = <span class="hljs-type">Mem</span>(<span class="hljs-number">32</span>, <span class="hljs-type">UInt</span>(<span class="hljs-number">32.</span><span class="hljs-type">W</span>))<br>  <span class="hljs-keyword">val</span> <span class="hljs-type">PC</span> = <span class="hljs-type">RegInit</span>(<span class="hljs-number">0.</span><span class="hljs-type">U</span>(<span class="hljs-number">32.</span><span class="hljs-type">W</span>))<br>  <span class="hljs-keyword">val</span> <span class="hljs-type">M</span> = <span class="hljs-type">Mem</span>(<span class="hljs-number">1024</span> / <span class="hljs-number">4</span>, <span class="hljs-type">UInt</span>(<span class="hljs-number">32.</span><span class="hljs-type">W</span>))<br>  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">Rread</span></span>(idx: <span class="hljs-type">UInt</span>) = <span class="hljs-type">Mux</span>(idx === <span class="hljs-number">0.</span><span class="hljs-type">U</span>, <span class="hljs-number">0.</span><span class="hljs-type">U</span>(<span class="hljs-number">32.</span><span class="hljs-type">W</span>), <span class="hljs-type">R</span>(idx))<br><br>  <span class="hljs-keyword">val</span> <span class="hljs-type">Ibundle</span> = <span class="hljs-keyword">new</span> <span class="hljs-type">Bundle</span> &#123;<br>    <span class="hljs-keyword">val</span> imm11_0 = <span class="hljs-type">UInt</span>(<span class="hljs-number">12.</span><span class="hljs-type">W</span>)<br>    <span class="hljs-keyword">val</span> rs1 = <span class="hljs-type">UInt</span>(<span class="hljs-number">5.</span><span class="hljs-type">W</span>)<br>    <span class="hljs-keyword">val</span> funct3 = <span class="hljs-type">UInt</span>(<span class="hljs-number">3.</span><span class="hljs-type">W</span>)<br>    <span class="hljs-keyword">val</span> rd = <span class="hljs-type">UInt</span>(<span class="hljs-number">5.</span><span class="hljs-type">W</span>)<br>    <span class="hljs-keyword">val</span> opcode = <span class="hljs-type">UInt</span>(<span class="hljs-number">7.</span><span class="hljs-type">W</span>)<br>  &#125;<br>  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">SignEXT</span></span>(imm11_0: <span class="hljs-type">UInt</span>) = <span class="hljs-type">Cat</span>(<span class="hljs-type">Fill</span>(<span class="hljs-number">20</span>, imm11_0(<span class="hljs-number">11</span>)), imm11_0)<br><br>  <span class="hljs-keyword">val</span> inst = <span class="hljs-type">M</span>(<span class="hljs-type">PC</span>(<span class="hljs-number">31</span>, <span class="hljs-number">2</span>)).asTypeOf(<span class="hljs-type">Ibundle</span>)<br>  <span class="hljs-keyword">val</span> isAddi = (inst.opcode === <span class="hljs-string">&quot;b0010011&quot;</span>.<span class="hljs-type">U</span>) &amp;&amp; (inst.funct3 === <span class="hljs-string">&quot;b000&quot;</span>.<span class="hljs-type">U</span>)<br>  <span class="hljs-keyword">val</span> isEbreak = inst.asUInt === <span class="hljs-string">&quot;x00100073&quot;</span>.<span class="hljs-type">U</span><br>  assert(isAddi || isEbreak, <span class="hljs-string">&quot;Invalid instruction 0x%x&quot;</span>, inst.asUInt)<br><br>  <span class="hljs-keyword">val</span> rs1Val = <span class="hljs-type">Rread</span>(<span class="hljs-type">Mux</span>(isEbreak, <span class="hljs-number">10.</span><span class="hljs-type">U</span>(<span class="hljs-number">5.</span><span class="hljs-type">W</span>), inst.rs1))<br>  <span class="hljs-keyword">val</span> rs2Val = <span class="hljs-type">Rread</span>(<span class="hljs-type">Mux</span>(isEbreak, <span class="hljs-number">11.</span><span class="hljs-type">U</span>(<span class="hljs-number">5.</span><span class="hljs-type">W</span>), <span class="hljs-number">0.</span><span class="hljs-type">U</span>(<span class="hljs-number">5.</span><span class="hljs-type">W</span>)))<br>  when(isAddi) &#123; <span class="hljs-type">R</span>(inst.rd) := rs1Val + <span class="hljs-type">SignEXT</span>(inst.imm11_0) &#125;<br>  when(isEbreak &amp;&amp; (rs1Val === <span class="hljs-number">0.</span><span class="hljs-type">U</span>)) &#123; printf(<span class="hljs-string">&quot;%c&quot;</span>, rs2Val(<span class="hljs-number">7</span>, <span class="hljs-number">0</span>)) &#125;<br>  io.halt := isEbreak &amp;&amp; (rs1Val === <span class="hljs-number">1.</span><span class="hljs-type">U</span>)<br>  <span class="hljs-type">PC</span> := <span class="hljs-type">PC</span> + <span class="hljs-number">4.</span><span class="hljs-type">U</span><br>&#125;<br><span class="hljs-class"><span class="hljs-keyword">object</span> <span class="hljs-title">YPC</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">App</span> </span>&#123;<br>  (<span class="hljs-keyword">new</span> chisel3.stage.<span class="hljs-type">ChiselStage</span>).emitVerilog(<span class="hljs-keyword">new</span> <span class="hljs-type">YPC</span>)<br>&#125;<br><br></code></pre></td></tr></table></figure><p>这个程序定一个了 YPC 模块，它有 4 个组件，分别是：</p><ul><li><p>io.halt: 这是一个输出，它会输出是否停机的信号；</p></li><li><p>R: 这是寄存器，一共 32 个，每一个 32 位；</p></li><li><p>M: 内存单元，每个单元都是 32 位，换句话说，这些单元的下标对应着的地址是 4 字节对齐的；</p></li><li><p>PC: 初始化为 0，标记着指令在 M 中的地址；</p></li><li><p>Ibundle: 这是一个 I 型指令的bundle；</p></li><li><p>inst: 指令；</p></li><li><p>isAddi、isEbreak: 指令判断，bool 类型；</p></li></ul><p>接下来的操作是YPC 的核心：</p><ul><li><p>如果是 ebreak 类型的指令，分别读取 a0、a1，根据 a0、a1 来赋予指令语义，比如是输出字符还是终止；</p></li><li><p>如果是 addi 类型的指令，分别读取 源寄存器、零寄存器，它们会被当做两个源寄存器，以便后面进行加法操作；</p></li><li><p>当是 ebreak 指令的时候， R(inst.rd) :&#x3D; rs1Val + SignEXT(inst.imm11_0)；</p></li><li><p>当是 ebreak &amp;&amp; a0 是 0，就输出字符 a1中的值，也就是传给的 ch；</p></li><li><p>当是 ebreak &amp;&amp; a0 是 1，就标记输出 io.halt 为 1。这个输出在运行时环境中会被用来判断是否停机。</p></li><li><p>最后更新 pc。</p></li></ul><h2 id="Chisel-到-Verilog-再到C-仿真"><a href="#Chisel-到-Verilog-再到C-仿真" class="headerlink" title="Chisel 到 Verilog 再到C++仿真"></a>Chisel 到 Verilog 再到C++仿真</h2><p>写好了 Chsel，想要利用 C++ 进行仿真，还得将它翻译成 Verilog，然后借助 verilator 将 HDL 翻译成 C++ 代码，然后我们可以写一个运行时环境，给它装载程序、控制停机、执行等：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;VYPC.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;VYPC___024root.h&quot;</span></span><br><span class="hljs-type">static</span> VYPC* top = <span class="hljs-literal">NULL</span>;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">step</span><span class="hljs-params">()</span> </span>&#123;<br>    top-&gt;clock = <span class="hljs-number">0</span>;<br>    top-&gt;<span class="hljs-built_in">eval</span>();<br>    top-&gt;clock = <span class="hljs-number">1</span>;<br>    top-&gt;<span class="hljs-built_in">eval</span>();<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">reset</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>&#123;<br>    top-&gt;reset = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span> (n--) &#123;<br>        <span class="hljs-built_in">step</span>();<br>    &#125;<br>    top-&gt;reset = <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">load_prog</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span>* bin)</span> </span>&#123;<br>    FILE* fp = <span class="hljs-built_in">fopen</span>(bin, <span class="hljs-string">&quot;r&quot;</span>);<br>    <span class="hljs-built_in">fread</span>(&amp;top-&gt;rootp-&gt;YPC__DOT__M, <span class="hljs-number">1</span>, <span class="hljs-number">1024</span>, fp);<br>    <span class="hljs-built_in">fclose</span>(fp);<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span>* argv[])</span> </span>&#123;<br>    top = <span class="hljs-keyword">new</span> VYPC;<br>    <span class="hljs-built_in">load_prog</span>(argv[<span class="hljs-number">1</span>]);<br>    <span class="hljs-built_in">reset</span>(<span class="hljs-number">20</span>);<br>    <span class="hljs-keyword">while</span> (!top-&gt;io_halt) &#123;<br>        <span class="hljs-built_in">step</span>();<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>假设已经生成了 HDL ，也就是 YPC.v，现在我们将它翻译成 C++。为了方便操作，可以写一个简单的 Makefile 来简化操作：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs Makefile">VERILATOR = verilator<br>SRC = main.cpp YPC.v<br>OBJ_SRC = hello.c<br>OBJ_BIN = prog.bin<br>OBJ_TARGET = prog<br>OBJ_DIR = obj_dir<br>RV32GCC = riscv64-linux-gnu-gcc -march=rv32g -mabi=ilp32<br>CFLAGS = -ffreestanding -nostdlib -static -Wl,-Ttext=0 -O2<br><br>RV64OBJCOPY = riscv64-linux-gnu-objcopy<br>RV64CP_FLAGS = -j .text -O binary<br><br>EXE = <span class="hljs-variable">$(OBJ_DIR)</span>/VYPC<br><br><span class="hljs-section">build: <span class="hljs-variable">$(EXE)</span></span><br><br><span class="hljs-variable">$(EXE)</span>: <span class="hljs-variable">$(SRC)</span><br>bear -- <span class="hljs-variable">$(VERILATOR)</span> --cc --trace --exe --build <span class="hljs-variable">$^</span><br>make -C <span class="hljs-variable">$(OBJ_DIR)</span> -f VYPC.mk<br><br><span class="hljs-section">run: <span class="hljs-variable">$(EXE)</span> <span class="hljs-variable">$(OBJ_BIN)</span></span><br>@<span class="hljs-variable">$(EXE)</span> <span class="hljs-variable">$(OBJ_BIN)</span><br><br><span class="hljs-variable">$(OBJ_TARGET)</span>: <span class="hljs-variable">$(OBJ_SRC)</span><br><span class="hljs-variable">$(RV32GCC)</span> <span class="hljs-variable">$(CFLAGS)</span> -o <span class="hljs-variable">$@</span> <span class="hljs-variable">$^</span><br><br><span class="hljs-variable">$(OBJ_BIN)</span>: <span class="hljs-variable">$(OBJ_TARGET)</span><br><span class="hljs-variable">$(RV64OBJCOPY)</span> <span class="hljs-variable">$(RV64CP_FLAGS)</span> <span class="hljs-variable">$^</span> <span class="hljs-variable">$@</span><br><span class="hljs-section">clean:</span><br>@rm -rf <span class="hljs-variable">$(OBJ_DIR)</span> prog*<br><br><span class="hljs-meta"><span class="hljs-keyword">.PHONY</span>: build run clean</span><br><br></code></pre></td></tr></table></figure><p>然后直接make run：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ make run<br>Hello, RISC-V!<br><br></code></pre></td></tr></table></figure><p>看来，YPC 已经达到了预期效果。</p><p>事实上，这个 YPC 可以很强大，只要实现所有的命令，它就可以运行所有的 riscv 程序！</p><h2 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h2><p>第一个问题：注意到 <code>YPC.scala</code> 中的一些调用，比如 <code>assert、printf</code>，这其实是 <code>Scala</code> 的函数调用，当然它依然会被 <code>sbt</code> 转化为 <code>HDL</code>:</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs Verilog"><span class="hljs-built_in">$fwrite</span>(<span class="hljs-number">32&#x27;h80000002</span>,<br>            <span class="hljs-string">&quot;Assertion failed: Invalid instruction 0x%x\n    at YPC.scala:25 assert(isAddi || isEbreak, \&quot;Invalid instruction 0x%%x\&quot;, inst.asUInt)\n&quot;</span><br>            ,_isEbreak_T); <span class="hljs-comment">// @[YPC.scala 25:9]</span><br><span class="hljs-built_in">$fwrite</span>(<span class="hljs-number">32&#x27;h80000002</span>,<span class="hljs-string">&quot;%c&quot;</span>,rs2Val[<span class="hljs-number">7</span>:<span class="hljs-number">0</span>]); <span class="hljs-comment">// @[YPC.scala 30:46]</span><br></code></pre></td></tr></table></figure><p>可以看到，这并不是真正的 HDL，他依然是函数调用，需要借助于仿真环境，它这次就会被 verilator 转化为 C++ 的系统调用（in verilated.h）：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-built_in">VL_FWRITEF</span>(<span class="hljs-number">0x80000002</span>U,<span class="hljs-string">&quot;%c&quot;</span>,<span class="hljs-number">8</span>,((<span class="hljs-number">0U</span> == ((<span class="hljs-number">0x100073</span>U<br>                                                == vlSelf-&gt;YPC__DOT__M_inst_MPORT_data)<br>                                                ? <span class="hljs-number">0xb</span>U<br>                                                : <span class="hljs-number">0U</span>))<br>                                        ? <span class="hljs-number">0U</span> : (<span class="hljs-number">0xff</span>U<br>                                                &amp; vlSelf-&gt;YPC__DOT__R<br>                                                [((<span class="hljs-number">0x100073</span>U<br>                                                   == vlSelf-&gt;YPC__DOT__M_inst_MPORT_data)<br>                                                   ? <span class="hljs-number">0xb</span>U<br>                                                   : <span class="hljs-number">0U</span>)])));<br><br><span class="hljs-built_in">VL_FWRITEF</span>(<span class="hljs-number">0x80000002</span>U,<span class="hljs-string">&quot;Assertion failed: Invalid instruction 0x%x\n    at YPC.scala:25 assert(isAddi || isEbreak, \&quot;Invalid instruction 0x%%x\&quot;, inst.asUInt)\n&quot;</span>,<br>                   <span class="hljs-number">32</span>,vlSelf-&gt;YPC__DOT__M_inst_MPORT_data);<br></code></pre></td></tr></table></figure><p>第二个问题：程序中有 jal 指令，按理说会打印出 <code>Assertion failed: Invalid instruction...</code>，因为我并没有实现 jal 指令，但是并没有注意到这个信息，为什么？</p><p>答案很简答，因为这个调用：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">halt</span><span class="hljs-params">(<span class="hljs-type">int</span> code)</span> &#123; ebreak(<span class="hljs-number">1</span>, code); <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>); &#125;<br></code></pre></td></tr></table></figure><p>首先是 halt 了，然后才死循环调用 jal 了，事实上当：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs Scala">io.halt := isEbreak &amp;&amp; (rs1Val === <span class="hljs-number">1.</span><span class="hljs-type">U</span>)<br><span class="hljs-type">PC</span> := <span class="hljs-type">PC</span> + <span class="hljs-number">4.</span><span class="hljs-type">U</span><br></code></pre></td></tr></table></figure><p>的时候，运行时环境已经结束了二进制程序的继续推进：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span>* argv[])</span> </span>&#123;<br>    top = <span class="hljs-keyword">new</span> VYPC;<br>    <span class="hljs-built_in">load_prog</span>(argv[<span class="hljs-number">1</span>]);<br>    <span class="hljs-built_in">reset</span>(<span class="hljs-number">20</span>);<br>    <span class="hljs-keyword">while</span> (!top-&gt;io_halt) &#123;<br>        <span class="hljs-built_in">step</span>();<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;span id=&quot;more&quot;&gt;&lt;/span&gt;

&lt;h2 id=&quot;一、前言&quot;&gt;&lt;a href=&quot;#一、前言&quot; class=&quot;headerlink&quot; title=&quot;一、前言&quot;&gt;&lt;/a&gt;一、前言&lt;/h2&gt;&lt;p&gt;本文尝试去分析 YSYX 中的一个实例 &lt;a href=&quot;https://</summary>
      
    
    
    
    <category term="PA2" scheme="http://blog.luliang.online/categories/PA2/"/>
    
    <category term="模拟器" scheme="http://blog.luliang.online/categories/PA2/%E6%A8%A1%E6%8B%9F%E5%99%A8/"/>
    
    
    <category term="模拟器" scheme="http://blog.luliang.online/tags/%E6%A8%A1%E6%8B%9F%E5%99%A8/"/>
    
    <category term="YPC" scheme="http://blog.luliang.online/tags/YPC/"/>
    
  </entry>
  
</feed>
